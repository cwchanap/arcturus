---
import CasinoLayout from '../layouts/casino.astro';
import { createDb } from '../lib/db';
import { getLlmSettings, AI_MODELS, AI_PROVIDERS } from '../lib/llm-settings';

const session = Astro.locals.session;

if (!session) {
	return Astro.redirect('/signin');
}

const { user } = session;
const fallbackInitial = user?.name?.[0]?.toUpperCase() ?? user?.email?.[0]?.toUpperCase() ?? 'A';

const runtime = Astro.locals.runtime;

const dbBinding = runtime?.env?.DB ?? null;

let aiSettings = {
	provider: 'openai',
	model: 'gpt-4o',
	openaiApiKey: null as string | null,
	geminiApiKey: null as string | null,
	updatedAt: new Date(0),
};

if (dbBinding) {
	try {
		const db = createDb(dbBinding);
		const result = await getLlmSettings(db, user.id);
		aiSettings = {
			provider: result.provider,
			model: result.model,
			openaiApiKey: result.openaiApiKey,
			geminiApiKey: result.geminiApiKey,
			updatedAt: result.updatedAt,
		};
	} catch (error) {
		console.error('Error loading AI rival settings:', error);
	}
}

const aiModelOptions = AI_MODELS;
const aiProviderOptions = AI_PROVIDERS;
const providerLabels = {
	openai: 'OpenAI',
	gemini: 'Gemini',
} as const;
const modelLabels: Record<string, string> = {
	'gpt-4o': 'GPT-4o',
	'gemini-2.5-flash': 'Gemini 2.5 Flash',
	'gemini-2.5-flash-lite': 'Gemini 2.5 Flash Lite',
};
const aiSettingsPayload = JSON.stringify({
	provider: aiSettings.provider,
	model: aiSettings.model,
	// Never send actual API keys to the client (security)
	hasOpenaiKey: Boolean(aiSettings.openaiApiKey),
	hasGeminiKey: Boolean(aiSettings.geminiApiKey),
	updatedAt: aiSettings.updatedAt.toISOString(),
});
---

<CasinoLayout title="Player Profile - Arcturus Casino">
	<section class="relative overflow-hidden">
		<div class="absolute inset-0 pointer-events-none">
			<div class="absolute top-24 -left-20 h-72 w-72 bg-yellow-500/10 rounded-full blur-3xl"></div>
			<div class="absolute bottom-10 right-0 h-64 w-64 bg-amber-500/10 rounded-full blur-3xl"></div>
		</div>

		<div class="relative max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-20">
			<div class="bg-slate-900/80 border border-yellow-500/20 rounded-3xl shadow-2xl">
				<div class="flex flex-col gap-10 p-8 sm:p-12">
					<div class="flex flex-col md:flex-row md:items-center md:justify-between gap-8">
						<div class="flex items-center gap-5">
							<div
								class="flex h-20 w-20 items-center justify-center rounded-2xl bg-gradient-to-br from-yellow-400 via-amber-500 to-yellow-600 text-3xl font-bold text-slate-900"
							>
								{
									user.image ? (
										<img
											src={user.image}
											alt={user.name ?? user.email ?? 'Player Avatar'}
											class="h-20 w-20 rounded-2xl object-cover"
										/>
									) : (
										<span>{fallbackInitial}</span>
									)
								}
							</div>
							<div>
								<p class="text-sm uppercase tracking-widest text-yellow-400/80">Player Profile</p>
								<h1 class="mt-2 text-3xl font-semibold text-white">
									{user.name ?? 'Casino Adventurer'}
								</h1>
								<p class="text-slate-400">{user.email}</p>
							</div>
						</div>
						<div class="flex items-center gap-4 self-start md:self-auto">
							<span
								class={`inline-flex items-center gap-2 rounded-full border px-4 py-1 text-xs font-semibold uppercase tracking-widest ${
									user.emailVerified
										? 'border-emerald-400/40 text-emerald-300'
										: 'border-yellow-500/40 text-yellow-300'
								}`}
							>
								{user.emailVerified ? 'Email Verified' : 'Verification Pending'}
							</span>
							<button
								id="signout-btn"
								type="button"
								class="group relative inline-flex items-center gap-2 overflow-hidden rounded-full border border-yellow-500/40 bg-slate-900/60 px-6 py-3 text-sm font-semibold text-yellow-300 transition focus:outline-none focus:ring-2 focus:ring-yellow-500/60 focus:ring-offset-2 focus:ring-offset-slate-900"
							>
								<span
									class="absolute inset-0 -z-10 translate-y-full bg-gradient-to-r from-yellow-400 via-amber-500 to-yellow-600 opacity-90 transition-transform duration-300 group-hover:translate-y-0"
								></span>
								<span class="group-hover:text-slate-900">Sign out</span>
							</button>
						</div>
					</div>

					<div class="grid grid-cols-1 gap-6 md:grid-cols-2">
						<div class="rounded-2xl border border-white/5 bg-slate-950/40 p-6">
							<h2 class="text-lg font-semibold text-white">Account Details</h2>
							<dl class="mt-6 space-y-4 text-sm text-slate-300">
								<div class="flex items-start justify-between">
									<dt class="text-slate-400">Player Name</dt>
									<dd class="font-medium text-white">{user.name ?? 'Not set'}</dd>
								</div>
								<div class="flex items-start justify-between">
									<dt class="text-slate-400">Email Address</dt>
									<dd class="font-medium text-white">{user.email}</dd>
								</div>
								<div class="flex items-start justify-between">
									<dt class="text-slate-400">Email Status</dt>
									<dd class="font-medium text-white">
										{user.emailVerified ? 'Verified' : 'Awaiting verification'}
									</dd>
								</div>
							</dl>
						</div>
						<div class="rounded-2xl border border-white/5 bg-slate-950/40 p-6">
							<h2 class="text-lg font-semibold text-white">Casino Tips</h2>
							<ul class="mt-6 space-y-4 text-sm text-slate-300">
								<li class="flex items-start gap-3">
									<span class="text-xl">üéÅ</span>
									<span>Claim your daily chip bonus to keep the games going.</span>
								</li>
								<li class="flex items-start gap-3">
									<span class="text-xl">üèÜ</span>
									<span>Visit the tournaments page to join upcoming events.</span>
								</li>
								<li class="flex items-start gap-3">
									<span class="text-xl">ü§ù</span>
									<span>Invite friends for exclusive in-game rewards.</span>
								</li>
							</ul>
						</div>
					</div>
				</div>
			</div>

			<div class="mt-8 rounded-2xl border border-white/5 bg-slate-950/40 p-6">
				<div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
					<div>
						<h2 class="text-lg font-semibold text-white">AI Rival Settings</h2>
						<p class="text-sm text-slate-400">
							Choose your model provider and store API keys to enable the Gemini or OpenAI poker
							rival.
						</p>
					</div>
					<p
						id="ai-settings-feedback"
						class="text-xs font-semibold uppercase tracking-widest text-slate-400 text-right"
					>
						Updated {
							aiSettings.updatedAt.getTime() ? aiSettings.updatedAt.toLocaleDateString() : '‚Äî'
						}
					</p>
				</div>

				<form
					id="ai-settings-form"
					class="mt-6 grid grid-cols-1 gap-5 sm:grid-cols-2"
					data-initial-provider={aiSettings.provider}
					data-initial-settings={aiSettingsPayload}
				>
					<div class="col-span-full sm:col-span-1">
						<label for="ai-provider" class="block text-sm font-medium text-slate-200">
							Model Provider
						</label>
						<select
							id="ai-provider"
							name="provider"
							class="mt-2 w-full rounded-lg border border-slate-700 bg-slate-900/70 px-3 py-2 text-sm text-white focus:border-yellow-500 focus:outline-none focus:ring-1 focus:ring-yellow-500"
						>
							{
								aiProviderOptions.map((provider) => (
									<option value={provider} selected={aiSettings.provider === provider}>
										{providerLabels[provider]}
									</option>
								))
							}
						</select>
					</div>
					<div class="col-span-full sm:col-span-1">
						<label for="ai-model" class="block text-sm font-medium text-slate-200">
							Model Variant
						</label>
						<select
							id="ai-model"
							name="model"
							class="mt-2 w-full rounded-lg border border-slate-700 bg-slate-900/70 px-3 py-2 text-sm text-white focus:border-yellow-500 focus:outline-none focus:ring-1 focus:ring-yellow-500"
							data-model-options={JSON.stringify(aiModelOptions)}
							data-model-labels={JSON.stringify(modelLabels)}
							data-initial-model={aiSettings.model}
						>
							{
								aiModelOptions[aiSettings.provider].map((model) => (
									<option value={model} selected={aiSettings.model === model}>
										{modelLabels[model] ?? model}
									</option>
								))
							}
						</select>
					</div>

					<div class="col-span-full space-y-2">
						<label
							id="api-key-label"
							for="api-key"
							class="block text-sm font-medium text-slate-200"
						>
							{aiSettings.provider === 'openai' ? 'OpenAI API Key' : 'Gemini API Key'}
						</label>
						<div class="flex flex-col gap-2 sm:flex-row sm:items-center">
							<div class="relative flex-1">
								<input
									id="api-key"
									name="apiKey"
									type="password"
									placeholder={aiSettings.provider === 'openai' ? 'sk-...' : 'AIza...'}
									class="w-full rounded-lg border border-slate-700 bg-slate-900/70 px-3 py-2 pr-20 text-sm text-white focus:border-yellow-500 focus:outline-none focus:ring-1 focus:ring-yellow-500"
									autocomplete="off"
								/>
								<div class="absolute right-2 top-1/2 -translate-y-1/2 flex items-center gap-1">
									<button
										type="button"
										id="show-api-key"
										class="p-1.5 text-slate-400 hover:text-yellow-400 focus:outline-none focus:ring-1 focus:ring-yellow-500 rounded transition-colors"
										title="Show API key"
										style="display: none;"
									>
										<svg
											xmlns="http://www.w3.org/2000/svg"
											width="16"
											height="16"
											viewBox="0 0 24 24"
											fill="none"
											stroke="currentColor"
											stroke-width="2"
											stroke-linecap="round"
											stroke-linejoin="round"
										>
											<path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"></path>
											<circle cx="12" cy="12" r="3"></circle>
										</svg>
									</button>
									<button
										type="button"
										id="hide-api-key"
										class="p-1.5 text-slate-400 hover:text-yellow-400 focus:outline-none focus:ring-1 focus:ring-yellow-500 rounded transition-colors"
										title="Hide API key"
										style="display: none;"
									>
										<svg
											xmlns="http://www.w3.org/2000/svg"
											width="16"
											height="16"
											viewBox="0 0 24 24"
											fill="none"
											stroke="currentColor"
											stroke-width="2"
											stroke-linecap="round"
											stroke-linejoin="round"
										>
											<path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"></path>
											<path
												d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"
											></path>
											<path
												d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"
											></path>
											<line x1="2" x2="22" y1="2" y2="22"></line>
										</svg>
									</button>
									<button
										type="button"
										id="copy-api-key"
										class="p-1.5 text-slate-400 hover:text-yellow-400 focus:outline-none focus:ring-1 focus:ring-yellow-500 rounded transition-colors"
										title="Copy API key"
										style="display: none;"
									>
										<svg
											xmlns="http://www.w3.org/2000/svg"
											width="16"
											height="16"
											viewBox="0 0 24 24"
											fill="none"
											stroke="currentColor"
											stroke-width="2"
											stroke-linecap="round"
											stroke-linejoin="round"
										>
											<rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect>
											<path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path>
										</svg>
									</button>
								</div>
							</div>
							<div class="flex items-center gap-2">
								<span
									id="api-key-status"
									class="text-xs font-semibold uppercase tracking-widest text-slate-400"
								>
									{
										(aiSettings.provider === 'openai' && aiSettings.openaiApiKey) ||
										(aiSettings.provider === 'gemini' && aiSettings.geminiApiKey)
											? 'Saved'
											: 'Not saved'
									}
								</span>
								<button
									type="button"
									id="clear-api-key"
									class="text-xs text-rose-400 hover:text-rose-300 underline focus:outline-none focus:ring-1 focus:ring-rose-500 rounded px-1"
									style="display: none;"
								>
									Clear
								</button>
							</div>
						</div>
						<p id="api-key-help" class="text-xs text-slate-400">
							{
								aiSettings.provider === 'openai'
									? 'Required for the GPT-4o rival. Keys are stored per account and never shown back in full.'
									: 'Used for Gemini Flash rivals. Leave blank to keep the previously stored key.'
							}
						</p>
					</div>

					<div class="col-span-full flex justify-end">
						<button
							type="submit"
							class="inline-flex items-center gap-2 rounded-lg bg-gradient-to-r from-yellow-500 via-amber-500 to-yellow-600 px-4 py-2 text-sm font-semibold text-slate-900 transition hover:from-yellow-400 hover:to-amber-500 focus:outline-none focus:ring-2 focus:ring-yellow-500/60 focus:ring-offset-2 focus:ring-offset-slate-950"
						>
							Save Rival Preferences
						</button>
					</div>
				</form>
			</div>
		</div>
	</section>

	<!-- Toast Notification -->
	<div
		id="toast-notification"
		class="fixed bottom-4 right-4 bg-emerald-500 text-white px-4 py-3 rounded-lg shadow-lg flex items-center gap-2 transition-all duration-300 opacity-0 pointer-events-none translate-y-2"
		style="z-index: 9999;"
	>
		<svg
			xmlns="http://www.w3.org/2000/svg"
			width="20"
			height="20"
			viewBox="0 0 24 24"
			fill="none"
			stroke="currentColor"
			stroke-width="2"
			stroke-linecap="round"
			stroke-linejoin="round"
		>
			<polyline points="20 6 9 17 4 12"></polyline>
		</svg>
		<span id="toast-message">Copied to clipboard!</span>
	</div>
</CasinoLayout>

<script>
	import { authClient } from '../lib/auth-client';

	const signoutBtn = document.getElementById('signout-btn');

	signoutBtn?.addEventListener('click', async () => {
		try {
			await authClient.signOut();
			window.location.href = '/signin';
		} catch (error) {
			console.error('Sign out error:', error);
		}
	});

	let aiState = {
		provider: 'openai',
		model: 'gpt-4o',
		hasOpenaiKey: false,
		hasGeminiKey: false,
	};

	const aiForm = document.getElementById('ai-settings-form');

	if (aiForm instanceof HTMLFormElement && typeof aiForm.dataset.initialSettings === 'string') {
		try {
			const parsed = JSON.parse(aiForm.dataset.initialSettings);
			aiState = {
				provider: parsed.provider ?? aiState.provider,
				model: parsed.model ?? aiState.model,
				hasOpenaiKey: Boolean(parsed.hasOpenaiKey),
				hasGeminiKey: Boolean(parsed.hasGeminiKey),
			};
		} catch (error) {
			console.error('Failed to parse initial AI settings:', error);
		}
	}

	const providerSelect = document.getElementById('ai-provider');
	const modelSelect = document.getElementById('ai-model');
	const apiKeyInput = document.getElementById('api-key');
	const apiKeyLabel = document.getElementById('api-key-label');
	const apiKeyStatus = document.getElementById('api-key-status');
	const apiKeyHelp = document.getElementById('api-key-help');
	const clearKeyButton = document.getElementById('clear-api-key');
	const showKeyButton = document.getElementById('show-api-key');
	const hideKeyButton = document.getElementById('hide-api-key');
	const copyKeyButton = document.getElementById('copy-api-key');
	const feedbackEl = document.getElementById('ai-settings-feedback');
	const toastEl = document.getElementById('toast-notification');
	const toastMessage = document.getElementById('toast-message');

	// Track if user wants to explicitly clear the API key
	let clearKeyRequested = false;
	// Cache for revealed API key (only fetched when user requests to see it)
	let revealedApiKey: string | null = null;
	let isKeyRevealed = false;
	// Store key lengths for proper masking
	let openaiKeyLength = 0;
	let geminiKeyLength = 0;

	let modelOptions = {};
	if (typeof modelSelect?.dataset.modelOptions === 'string') {
		try {
			modelOptions = JSON.parse(modelSelect.dataset.modelOptions);
		} catch (error) {
			console.error('Failed to parse model options dataset:', error);
		}
	}

	let modelLabels = {};
	if (typeof modelSelect?.dataset.modelLabels === 'string') {
		try {
			modelLabels = JSON.parse(modelSelect.dataset.modelLabels);
		} catch (error) {
			console.error('Failed to parse model labels dataset:', error);
		}
	}

	function updateApiKeyUI(provider: string, clearInput = false) {
		if (!apiKeyLabel || !apiKeyInput || !apiKeyStatus || !apiKeyHelp) return;

		const isOpenAI = provider === 'openai';
		const hasKey = isOpenAI ? aiState.hasOpenaiKey : aiState.hasGeminiKey;

		// Always update label and help text
		apiKeyLabel.textContent = isOpenAI ? 'OpenAI API Key' : 'Gemini API Key';

		apiKeyHelp.textContent = isOpenAI
			? 'Required for the GPT-4o rival. Keys are stored per account and never shown back in full.'
			: 'Used for Gemini Flash rivals. Leave blank to keep the previously stored key.';

		if (apiKeyInput instanceof HTMLInputElement) {
			apiKeyInput.placeholder = isOpenAI ? 'sk-...' : 'AIza...';

			// If clearing input (e.g., provider change), clear it
			if (clearInput) {
				apiKeyInput.value = '';
			}
			// If key is currently revealed, don't change the value
			else if (isKeyRevealed) {
				// Keep the revealed key, just update placeholder
				apiKeyInput.placeholder = 'Saved key (masked)';
			}
			// If key is saved, show masked placeholder to indicate it
			else if (hasKey) {
				const keyLength = isOpenAI ? openaiKeyLength : geminiKeyLength;
				// Use actual key length if known, otherwise default to 20
				apiKeyInput.value = '‚Ä¢'.repeat(keyLength || 20);
				apiKeyInput.placeholder = 'Saved key (masked)';
			}
			// No key saved, keep input empty
			else {
				apiKeyInput.value = '';
			}
		}

		apiKeyStatus.textContent = hasKey ? 'Saved' : 'Not saved';

		// Show/hide Clear button based on whether key is saved
		if (clearKeyButton instanceof HTMLButtonElement) {
			clearKeyButton.style.display = hasKey ? 'inline-block' : 'none';
		}

		// Show/hide show, hide, and copy buttons based on whether key is saved
		if (showKeyButton instanceof HTMLButtonElement) {
			showKeyButton.style.display = hasKey && !isKeyRevealed ? 'block' : 'none';
		}
		if (hideKeyButton instanceof HTMLButtonElement) {
			hideKeyButton.style.display = hasKey && isKeyRevealed ? 'block' : 'none';
		}
		if (copyKeyButton instanceof HTMLButtonElement) {
			copyKeyButton.style.display = hasKey ? 'block' : 'none';
		}

		// Reset revealed state when clearing or changing provider
		if (clearInput) {
			revealedApiKey = null;
			isKeyRevealed = false;
		}
	}

	function setFeedback(message: string, tone = 'neutral') {
		if (!feedbackEl) return;

		feedbackEl.textContent = message;
		feedbackEl.classList.remove('text-emerald-400', 'text-rose-400', 'text-slate-400');
		if (tone === 'success') {
			feedbackEl.classList.add('text-emerald-400');
		} else if (tone === 'error') {
			feedbackEl.classList.add('text-rose-400');
		} else {
			feedbackEl.classList.add('text-slate-400');
		}
	}

	function showToast(message: string) {
		if (!toastEl || !toastMessage) return;

		toastMessage.textContent = message;
		toastEl.classList.remove('opacity-0', 'pointer-events-none', 'translate-y-2');
		toastEl.classList.add('opacity-100', 'translate-y-0');

		setTimeout(() => {
			toastEl.classList.add('opacity-0', 'pointer-events-none', 'translate-y-2');
			toastEl.classList.remove('opacity-100', 'translate-y-0');
		}, 3000);
	}

	function populateModels(provider, desiredModel) {
		if (!(modelSelect instanceof HTMLSelectElement)) return;

		const models = Array.isArray(modelOptions?.[provider]) ? modelOptions[provider] : [];
		modelSelect.innerHTML = '';

		models.forEach((model) => {
			const option = document.createElement('option');
			option.value = model;
			option.textContent = modelLabels?.[model] ?? model;
			if (model === desiredModel) {
				option.selected = true;
			}
			modelSelect.appendChild(option);
		});

		if (models.length > 0 && !models.includes(desiredModel)) {
			modelSelect.value = models[0];
		}
	}

	if (providerSelect instanceof HTMLSelectElement) {
		providerSelect.value = aiState.provider;
		populateModels(aiState.provider, aiState.model);
		updateApiKeyUI(aiState.provider); // Initialize input to show masked value if key is saved

		providerSelect.addEventListener('change', () => {
			const nextProvider = providerSelect.value;
			populateModels(
				nextProvider,
				modelSelect instanceof HTMLSelectElement ? modelSelect.value : '',
			);
			clearKeyRequested = false; // Reset clear flag when changing provider
			revealedApiKey = null; // Clear cached key when switching providers
			isKeyRevealed = false; // Reset revealed state
			updateApiKeyUI(nextProvider, false); // Show masked value for saved keys
		});
	}

	updateApiKeyUI(aiState.provider);

	// Fetch actual API key from server (only when user requests to see/copy it)
	async function fetchApiKey(provider: string): Promise<string | null> {
		try {
			const response = await fetch('/api/profile/reveal-api-key', {
				method: 'POST',
				headers: {
					'content-type': 'application/json',
				},
				body: JSON.stringify({ provider }),
			});

			if (!response.ok) {
				throw new Error('Failed to retrieve API key');
			}

			const data: unknown = await response.json();

			// Type guard: ensure data has apiKey property
			if (data && typeof data === 'object' && 'apiKey' in data && typeof data.apiKey === 'string') {
				return data.apiKey;
			}

			return null;
		} catch (error) {
			console.error('Error fetching API key:', error);
			return null;
		}
	}

	// Handle Show API key button click
	if (showKeyButton instanceof HTMLButtonElement) {
		showKeyButton.addEventListener('click', async () => {
			const currentProvider =
				providerSelect instanceof HTMLSelectElement ? providerSelect.value : aiState.provider;

			if (!revealedApiKey) {
				// Fetch the key from server if not cached
				revealedApiKey = await fetchApiKey(currentProvider);

				if (!revealedApiKey) {
					console.error('Failed to fetch API key');
					alert('Failed to retrieve API key');
					return;
				}

				// Store the key length for proper masking
				if (currentProvider === 'openai') {
					openaiKeyLength = revealedApiKey.length;
				} else {
					geminiKeyLength = revealedApiKey.length;
				}
			}

			// Show the actual key
			if (apiKeyInput instanceof HTMLInputElement) {
				apiKeyInput.value = revealedApiKey;
				apiKeyInput.type = 'text';
			}
			isKeyRevealed = true;
			updateApiKeyUI(currentProvider);
		});
	}

	// Handle Hide API key button click
	if (hideKeyButton instanceof HTMLButtonElement) {
		hideKeyButton.addEventListener('click', () => {
			const currentProvider =
				providerSelect instanceof HTMLSelectElement ? providerSelect.value : aiState.provider;

			// Hide the key
			if (apiKeyInput instanceof HTMLInputElement) {
				const keyLength = currentProvider === 'openai' ? openaiKeyLength : geminiKeyLength;
				apiKeyInput.value = '‚Ä¢'.repeat(keyLength || 20);
				apiKeyInput.type = 'password';
			}
			isKeyRevealed = false;
			updateApiKeyUI(currentProvider);
		});
	}

	// Handle Copy API key button click
	if (copyKeyButton instanceof HTMLButtonElement) {
		copyKeyButton.addEventListener('click', async () => {
			if (!revealedApiKey) {
				// Fetch the key from server if not cached
				const currentProvider =
					providerSelect instanceof HTMLSelectElement ? providerSelect.value : aiState.provider;
				revealedApiKey = await fetchApiKey(currentProvider);

				if (!revealedApiKey) {
					alert('Failed to retrieve API key');
					return;
				}
			}

			// Store the key length for proper masking
			const currentProvider =
				providerSelect instanceof HTMLSelectElement ? providerSelect.value : aiState.provider;
			if (currentProvider === 'openai') {
				openaiKeyLength = revealedApiKey.length;
			} else {
				geminiKeyLength = revealedApiKey.length;
			}

			// Copy to clipboard
			try {
				await navigator.clipboard.writeText(revealedApiKey);
				showToast('API key copied to clipboard!');
			} catch (error) {
				console.error('Failed to copy to clipboard:', error);
				showToast('Failed to copy to clipboard');
			}
		});
	}

	// Handle Clear button click
	if (clearKeyButton instanceof HTMLButtonElement) {
		clearKeyButton.addEventListener('click', () => {
			if (confirm('Are you sure you want to remove your saved API key?')) {
				clearKeyRequested = true;
				if (apiKeyInput instanceof HTMLInputElement) {
					apiKeyInput.value = '';
				}
				// Trigger form submission
				if (aiForm instanceof HTMLFormElement) {
					aiForm.requestSubmit();
				}
			}
		});
	}

	aiForm?.addEventListener('submit', async (event) => {
		event.preventDefault();
		if (
			!(providerSelect instanceof HTMLSelectElement) ||
			!(modelSelect instanceof HTMLSelectElement)
		) {
			return;
		}

		const currentProvider = providerSelect.value;
		const apiKeyValue = apiKeyInput instanceof HTMLInputElement ? apiKeyInput.value.trim() : '';

		// Ignore masked placeholder - treat it as empty
		// Check if the value is only bullet characters (any length)
		const isMaskedPlaceholder = apiKeyValue.length > 0 && /^‚Ä¢+$/.test(apiKeyValue);
		const actualKeyValue = isMaskedPlaceholder ? '' : apiKeyValue;

		// Payload logic:
		// - If user clicked "Clear" ‚Üí send empty string ‚Üí server clears key
		// - If user entered a new value ‚Üí send value ‚Üí server updates key
		// - If field is empty/masked and no clear requested ‚Üí don't send ‚Üí server preserves key
		// - Inactive provider ‚Üí don't send (undefined) ‚Üí server preserves existing key
		const payload: {
			provider: string;
			model: string;
			openaiApiKey?: string;
			geminiApiKey?: string;
		} = {
			provider: currentProvider,
			model: modelSelect.value,
		};

		// Include API key if: user entered a new value OR explicitly requested to clear
		if ((actualKeyValue.length > 0 && !isMaskedPlaceholder) || clearKeyRequested) {
			if (currentProvider === 'openai') {
				payload.openaiApiKey = actualKeyValue; // Empty string if clearing, new value if updating
			} else if (currentProvider === 'gemini') {
				payload.geminiApiKey = actualKeyValue; // Empty string if clearing, new value if updating
			}
		}

		// Reset clear flag after building payload
		clearKeyRequested = false;

		setFeedback('Saving‚Ä¶', 'neutral');

		try {
			const response = await fetch('/api/profile/llm-settings', {
				method: 'POST',
				headers: {
					'content-type': 'application/json',
				},
				body: JSON.stringify(payload),
			});

			if (!response.ok) {
				const errorText = await response.text();
				throw new Error(errorText || `Request failed with status ${response.status}`);
			}

			const data = await response.json();
			const updated = data?.settings ?? {};

			aiState = {
				provider: updated.provider ?? payload.provider,
				model: updated.model ?? payload.model,
				hasOpenaiKey: Boolean(updated.hasOpenaiKey),
				hasGeminiKey: Boolean(updated.hasGeminiKey),
			};

			if (providerSelect.value !== aiState.provider) {
				providerSelect.value = aiState.provider;
			}

			populateModels(aiState.provider, aiState.model);
			updateApiKeyUI(aiState.provider); // Update UI to show masked value if key is saved

			setFeedback('Rival preferences saved', 'success');
		} catch (error) {
			console.error('Failed to save AI rival settings:', error);
			setFeedback('Could not save preferences', 'error');
		}
	});
</script>
