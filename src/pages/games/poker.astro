---
import CasinoLayout from '../../layouts/casino.astro';
import PlayingCard from '../../components/PlayingCard.astro';
import PokerChip from '../../components/PokerChip.astro';

const user = Astro.locals.user;

if (!user) {
	return Astro.redirect('/signin');
}
---

<CasinoLayout title="Texas Hold'em Poker - Arcturus Casino">
	<div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
		<!-- Game Header -->
		<div class="flex items-center justify-between mb-8">
			<div>
				<a
					href="/#games"
					class="text-slate-400 hover:text-yellow-400 transition-colors mb-2 inline-block"
				>
					‚Üê Back to Games
				</a>
				<h1
					class="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-amber-500"
				>
					Texas Hold'em Poker
				</h1>
			</div>
			<div class="flex items-center gap-4">
				<div class="bg-slate-800 px-6 py-3 rounded-lg border border-yellow-500/30">
					<div class="text-xs text-slate-400 mb-1">Your Balance</div>
					<div class="text-2xl font-bold text-yellow-400">$1,000</div>
				</div>
			</div>
		</div>

		<!-- Poker Table -->
		<div class="felt-table rounded-3xl p-8 mb-8 relative min-h-[600px]">
			<!-- Pot Display -->
			<div class="absolute top-8 left-1/2 -translate-x-1/2">
				<div
					class="bg-slate-900/80 backdrop-blur-sm px-6 py-3 rounded-full border-2 border-yellow-500/50"
				>
					<div class="text-xs text-slate-400 text-center mb-1">POT</div>
					<div class="text-2xl font-bold text-yellow-400" id="pot-amount">$0</div>
				</div>
			</div>

			<!-- Community Cards -->
			<div class="absolute top-32 left-1/2 -translate-x-1/2">
				<div class="flex gap-3" id="community-cards">
					<div
						class="w-20 h-28 bg-slate-800/50 rounded-lg border-2 border-dashed border-slate-600 flex items-center justify-center text-slate-600"
					>
						?
					</div>
					<div
						class="w-20 h-28 bg-slate-800/50 rounded-lg border-2 border-dashed border-slate-600 flex items-center justify-center text-slate-600"
					>
						?
					</div>
					<div
						class="w-20 h-28 bg-slate-800/50 rounded-lg border-2 border-dashed border-slate-600 flex items-center justify-center text-slate-600"
					>
						?
					</div>
					<div
						class="w-20 h-28 bg-slate-800/50 rounded-lg border-2 border-dashed border-slate-600 flex items-center justify-center text-slate-600"
					>
						?
					</div>
					<div
						class="w-20 h-28 bg-slate-800/50 rounded-lg border-2 border-dashed border-slate-600 flex items-center justify-center text-slate-600"
					>
						?
					</div>
				</div>
			</div>

			<!-- Opponents (simplified - 3 positions) -->
			<div class="absolute top-8 left-8">
				<div class="bg-slate-900/80 backdrop-blur-sm p-4 rounded-lg border border-slate-700">
					<div class="text-sm text-slate-300 mb-2">Player 2</div>
					<div class="flex gap-2 mb-2" id="opponent1-cards">
						<PlayingCard value="?" suit="spades" faceDown={true} />
						<PlayingCard value="?" suit="spades" faceDown={true} />
					</div>
					<div class="text-xs text-yellow-400">$500</div>
				</div>
			</div>

			<div class="absolute top-8 right-8">
				<div class="bg-slate-900/80 backdrop-blur-sm p-4 rounded-lg border border-slate-700">
					<div class="text-sm text-slate-300 mb-2">Player 3</div>
					<div class="flex gap-2 mb-2" id="opponent2-cards">
						<PlayingCard value="?" suit="spades" faceDown={true} />
						<PlayingCard value="?" suit="spades" faceDown={true} />
					</div>
					<div class="text-xs text-yellow-400">$750</div>
				</div>
			</div>

			<!-- Player's Hand -->
			<div class="absolute bottom-8 left-1/2 -translate-x-1/2">
				<div class="bg-slate-900/90 backdrop-blur-sm p-6 rounded-xl border-2 border-yellow-500/50">
					<div class="text-center mb-4">
						<div class="text-sm text-slate-400 mb-1">Your Hand</div>
						<div class="text-lg font-bold text-yellow-400" id="hand-strength">--</div>
					</div>
					<div class="flex gap-3 justify-center mb-4" id="player-cards">
						<!-- Cards will be inserted here by JavaScript -->
					</div>
					<div class="text-sm text-center text-yellow-400">
						Your Bet: <span id="current-bet">$0</span>
					</div>
				</div>
			</div>
		</div>

		<!-- Game Controls -->
		<div class="bg-slate-900 rounded-xl p-6 border border-slate-700">
			<div class="grid grid-cols-1 md:grid-cols-2 gap-6">
				<!-- Betting Controls -->
				<div>
					<h3 class="text-lg font-bold text-white mb-4">Betting Controls</h3>
					<div class="space-y-3">
						<div class="flex gap-2">
							<button
								id="btn-fold"
								class="flex-1 bg-red-600 hover:bg-red-700 text-white py-3 rounded-lg font-bold transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
							>
								FOLD
							</button>
							<button
								id="btn-check"
								class="flex-1 bg-blue-600 hover:bg-blue-700 text-white py-3 rounded-lg font-bold transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
							>
								CHECK
							</button>
						</div>
						<div class="flex gap-2">
							<button
								id="btn-call"
								class="flex-1 bg-green-600 hover:bg-green-700 text-white py-3 rounded-lg font-bold transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
							>
								CALL
							</button>
							<button
								id="btn-raise"
								class="flex-1 bg-gradient-to-r from-yellow-600 to-amber-600 hover:from-yellow-700 hover:to-amber-700 text-white py-3 rounded-lg font-bold transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
							>
								RAISE
							</button>
						</div>
						<div class="flex gap-2 items-center">
							<input
								type="range"
								id="bet-slider"
								min="10"
								max="1000"
								step="10"
								value="50"
								class="flex-1"
							/>
							<span id="bet-amount" class="text-yellow-400 font-bold min-w-[80px] text-right"
								>$50</span
							>
						</div>
					</div>
				</div>

				<!-- Quick Bet Chips -->
				<div>
					<h3 class="text-lg font-bold text-white mb-4">Quick Bet</h3>
					<div class="grid grid-cols-4 gap-3">
						<button class="quick-bet-chip hover:scale-110 transition-transform" data-amount="10">
							<PokerChip value={10} color="red" />
						</button>
						<button class="quick-bet-chip hover:scale-110 transition-transform" data-amount="25">
							<PokerChip value={25} color="blue" />
						</button>
						<button class="quick-bet-chip hover:scale-110 transition-transform" data-amount="50">
							<PokerChip value={50} color="green" />
						</button>
						<button class="quick-bet-chip hover:scale-110 transition-transform" data-amount="100">
							<PokerChip value={100} color="black" />
						</button>
					</div>
					<button id="btn-deal" class="w-full mt-4 btn-gold py-4 rounded-lg font-bold text-lg">
						DEAL NEW HAND
					</button>
				</div>
			</div>

			<!-- Game Status -->
			<div class="mt-6 p-4 bg-slate-800 rounded-lg border border-slate-700">
				<div class="text-sm text-slate-400 mb-1">Game Status</div>
				<div id="game-status" class="text-lg font-bold text-yellow-400">
					Click "DEAL NEW HAND" to start
				</div>
			</div>

			<div class="mt-6 p-4 bg-slate-800 rounded-lg border border-slate-700">
				<div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
					<div>
						<div class="text-sm text-slate-400 mb-1">AI Rival</div>
						<div id="ai-rival-status" class="text-sm text-slate-300">Loading rival settings‚Ä¶</div>
					</div>
					<button
						id="btn-ai-move"
						class="inline-flex items-center justify-center gap-2 rounded-lg bg-gradient-to-r from-blue-500 to-indigo-600 px-4 py-2 text-sm font-semibold text-white transition hover:from-blue-400 hover:to-indigo-500 disabled:cursor-not-allowed disabled:opacity-60"
					>
						Ask AI Rival
					</button>
				</div>
				<p class="mt-3 text-xs text-slate-500">
					Configure API keys in your
					<a href="/profile" class="text-yellow-400 hover:underline">profile settings</a>
					to enable Gemini or OpenAI rivals.
				</p>
			</div>
		</div>

		<!-- Game Info -->
		<div class="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6">
			<div class="bg-slate-900 rounded-xl p-6 border border-slate-700">
				<h3 class="text-xl font-bold text-yellow-400 mb-4">üéØ Game Rules</h3>
				<ul class="space-y-2 text-sm text-slate-300">
					<li>‚Ä¢ Each player gets 2 hole cards</li>
					<li>‚Ä¢ 5 community cards revealed in stages</li>
					<li>‚Ä¢ Make the best 5-card hand</li>
					<li>‚Ä¢ Highest hand wins the pot</li>
				</ul>
			</div>

			<div class="bg-slate-900 rounded-xl p-6 border border-slate-700">
				<h3 class="text-xl font-bold text-yellow-400 mb-4">üèÜ Hand Rankings</h3>
				<ul class="space-y-2 text-sm text-slate-300">
					<li>‚Ä¢ Royal Flush</li>
					<li>‚Ä¢ Straight Flush</li>
					<li>‚Ä¢ Four of a Kind</li>
					<li>‚Ä¢ Full House</li>
					<li>‚Ä¢ Flush</li>
				</ul>
			</div>

			<div class="bg-slate-900 rounded-xl p-6 border border-slate-700">
				<h3 class="text-xl font-bold text-yellow-400 mb-4">üí∞ Betting</h3>
				<ul class="space-y-2 text-sm text-slate-300">
					<li>‚Ä¢ Minimum bet: $10</li>
					<li>‚Ä¢ Maximum bet: $1,000</li>
					<li>‚Ä¢ Fold to quit round</li>
					<li>‚Ä¢ Check to pass</li>
				</ul>
			</div>
		</div>
	</div>
</CasinoLayout>

<script>
	// Poker game logic
	import type { Card, Suit, Player, BettingRound, GameContext } from '../../lib/poker';
	import {
		STARTING_CHIPS,
		SMALL_BLIND,
		BIG_BLIND,
		createPlayer,
		createAIPlayer,
		placeBet,
		postBlind,
		foldPlayer,
		resetPlayerForNewHand,
		resetCurrentBets,
		dealCardsToPlayer,
		awardChips,
		getActivePlayers,
		getNextPlayerIndex,
		isBettingRoundComplete,
		getHighestBet,
		getCallAmount,
		calculatePot,
		createAIConfig,
		makeAIDecision,
	} from '../../lib/poker';
	import type { AIConfig } from '../../lib/poker';

	type AiProvider = 'openai' | 'gemini';
	type AiSettings = {
		provider: AiProvider;
		model: string;
		openaiApiKey: string | null;
		geminiApiKey: string | null;
	};
	type AiMoveType = 'fold' | 'check' | 'call' | 'raise';
	type AiMove = {
		move: AiMoveType;
		amount?: number | null;
		raw: string;
	};

	class PokerGame {
		private deck: Card[] = [];
		private players: Player[] = [];
		private communityCards: Card[] = [];
		private pot = 0;
		private gamePhase: 'preflop' | 'flop' | 'turn' | 'river' | 'showdown' = 'preflop';
		private bettingRound: BettingRound | null = null;
		private currentPlayerIndex = 0;
		private dealerIndex = 0;
		private smallBlindIndex = 1;
		private bigBlindIndex = 2;
		private minimumBet = BIG_BLIND;
		private lastRaiseAmount = BIG_BLIND;
		private aiSettings: AiSettings | null = null;
		private isProcessingAction = false;
		private aiConfigs: Map<number, AIConfig> = new Map();

		constructor() {
			this.initDeck();
			this.initPlayers();
			this.attachEventListeners();
			this.highlightSuggestedMove(null);
			this.setAiButtonState({ disabled: true });
			this.loadAiSettings();
		}

		private initDeck() {
			const suits: Suit[] = ['hearts', 'diamonds', 'clubs', 'spades'];
			const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];

			this.deck = [];
			for (const suit of suits) {
				for (let i = 0; i < values.length; i++) {
					this.deck.push({ value: values[i], suit, rank: i + 2 });
				}
			}
		}

		private initPlayers() {
			this.players = [
				createPlayer(0, 'You', STARTING_CHIPS, false),
				createAIPlayer(1, 'Player 2', STARTING_CHIPS),
				createAIPlayer(2, 'Player 3', STARTING_CHIPS),
			];
			this.players[this.dealerIndex].isDealer = true;

			// Assign AI personalities
			this.aiConfigs.set(1, createAIConfig('tight-aggressive'));
			this.aiConfigs.set(2, createAIConfig('loose-aggressive'));
		}

		private shuffle() {
			for (let i = this.deck.length - 1; i > 0; i--) {
				const j = Math.floor(Math.random() * (i + 1));
				[this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
			}
		}

		private drawCard(): Card {
			return this.deck.pop()!;
		}

		public dealNewHand() {
			// Reset deck and shuffle
			this.initDeck();
			this.shuffle();

			// Reset players for new hand
			this.players = this.players.map(resetPlayerForNewHand);

			// Deal 2 cards to each player
			for (let i = 0; i < this.players.length; i++) {
				const card1 = this.drawCard();
				const card2 = this.drawCard();
				this.players[i] = dealCardsToPlayer(this.players[i], [card1, card2]);
			}

			// Reset community cards
			this.communityCards = [];

			// Post blinds
			this.players[this.smallBlindIndex] = postBlind(
				this.players[this.smallBlindIndex],
				SMALL_BLIND,
			);
			this.players[this.bigBlindIndex] = postBlind(this.players[this.bigBlindIndex], BIG_BLIND);

			// Set game state
			this.pot = calculatePot(this.players);
			this.gamePhase = 'preflop';
			this.bettingRound = 'preflop';
			this.minimumBet = BIG_BLIND;
			this.lastRaiseAmount = BIG_BLIND;

			// Start with player after big blind
			this.currentPlayerIndex = (this.bigBlindIndex + 1) % this.players.length;

			// Render UI
			this.renderPlayerCards();
			this.renderCommunityCards();
			this.updateOpponentUI();
			this.updateUI();
			this.highlightSuggestedMove(null);

			if (this.currentPlayerIndex === 0) {
				this.updateGameStatus('Your turn! Check, Call, Raise, or Fold');
			} else {
				this.updateGameStatus(`Waiting for ${this.players[this.currentPlayerIndex].name}...`);
				this.processAITurn();
			}
		}

		private renderPlayerCards() {
			const container = document.getElementById('player-cards');
			if (!container) return;

			const humanPlayer = this.players[0];
			if (!humanPlayer) return;

			container.innerHTML = humanPlayer.hand
				.map(
					(card) => `
				<div class="playing-card w-20 h-28 flex items-center justify-center">
					<div class="w-full h-full p-2 flex flex-col">
						<div class="text-xl font-bold ${card.suit === 'hearts' || card.suit === 'diamonds' ? 'text-red-600' : 'text-gray-900'}">
							${card.value}
						</div>
						<div class="flex-1 flex items-center justify-center text-4xl ${card.suit === 'hearts' || card.suit === 'diamonds' ? 'text-red-600' : 'text-gray-900'}">
							${this.getSuitSymbol(card.suit)}
						</div>
						<div class="text-xl font-bold text-right ${card.suit === 'hearts' || card.suit === 'diamonds' ? 'text-red-600' : 'text-gray-900'} rotate-180">
							${card.value}
						</div>
					</div>
				</div>
			`,
				)
				.join('');

			this.evaluateHand();
		}

		private renderCommunityCards() {
			const container = document.getElementById('community-cards');
			if (!container) return;

			const cards: (Card | null)[] = [...this.communityCards];
			while (cards.length < 5) {
				cards.push(null);
			}

			container.innerHTML = cards
				.map((card) => {
					if (!card) {
						return `
						<div class="w-20 h-28 bg-slate-800/50 rounded-lg border-2 border-dashed border-slate-600 flex items-center justify-center text-slate-600">
							?
						</div>
					`;
					}
					return `
					<div class="playing-card w-20 h-28 flex items-center justify-center">
						<div class="w-full h-full p-2 flex flex-col">
							<div class="text-xl font-bold ${card.suit === 'hearts' || card.suit === 'diamonds' ? 'text-red-600' : 'text-gray-900'}">
								${card.value}
							</div>
							<div class="flex-1 flex items-center justify-center text-4xl ${card.suit === 'hearts' || card.suit === 'diamonds' ? 'text-red-600' : 'text-gray-900'}">
								${this.getSuitSymbol(card.suit)}
							</div>
							<div class="text-xl font-bold text-right ${card.suit === 'hearts' || card.suit === 'diamonds' ? 'text-red-600' : 'text-gray-900'} rotate-180">
								${card.value}
							</div>
						</div>
					</div>
				`;
				})
				.join('');
		}

		private updateOpponentUI() {
			// Update opponent chip counts
			if (this.players[1]) {
				const opponent1Chips = document
					.querySelector('#opponent1-cards')
					?.parentElement?.querySelector('.text-xs.text-yellow-400');
				if (opponent1Chips) {
					opponent1Chips.textContent = `$${this.players[1].chips}`;
				}
			}
			if (this.players[2]) {
				const opponent2Chips = document
					.querySelector('#opponent2-cards')
					?.parentElement?.querySelector('.text-xs.text-yellow-400');
				if (opponent2Chips) {
					opponent2Chips.textContent = `$${this.players[2].chips}`;
				}
			}
		}

		private async processAITurn() {
			if (this.isProcessingAction) return;
			if (this.currentPlayerIndex === 0) return; // Not AI's turn

			const currentPlayer = this.players[this.currentPlayerIndex];
			if (!currentPlayer || !currentPlayer.isAI) return;

			// Random delay for AI decision (800-1500ms)
			const delay = 800 + Math.random() * 700;
			await new Promise((resolve) => setTimeout(resolve, delay));

			// Get AI config
			const aiConfig = this.aiConfigs.get(currentPlayer.id);
			if (!aiConfig) {
				// Fallback: just check/fold
				const highestBet = getHighestBet(this.players);
				const callAmount = getCallAmount(currentPlayer, highestBet);
				if (callAmount === 0) {
					this.updateGameStatus(`${currentPlayer.name} checks`);
				} else {
					this.players[this.currentPlayerIndex] = foldPlayer(currentPlayer);
					this.updateGameStatus(`${currentPlayer.name} folds`);
				}
				this.advanceTurn();
				return;
			}

			// Build game context for AI
			const context: GameContext = {
				player: currentPlayer,
				players: this.players,
				communityCards: this.communityCards,
				pot: this.pot,
				minimumBet: this.minimumBet,
				phase: this.gamePhase,
				bettingRound: this.bettingRound,
				position: this.getPlayerPosition(currentPlayer),
			};

			// Get AI decision
			const decision = makeAIDecision(context, aiConfig);

			// Execute decision
			const highestBet = getHighestBet(this.players);
			const callAmount = getCallAmount(currentPlayer, highestBet);

			switch (decision.action) {
				case 'fold':
					this.players[this.currentPlayerIndex] = foldPlayer(currentPlayer);
					this.updateGameStatus(`${currentPlayer.name} folds`);
					break;

				case 'check':
					this.updateGameStatus(`${currentPlayer.name} checks`);
					break;

				case 'call':
					if (callAmount > 0 && callAmount <= currentPlayer.chips) {
						this.players[this.currentPlayerIndex] = placeBet(currentPlayer, callAmount);
						this.pot = calculatePot(this.players);
						this.updateGameStatus(`${currentPlayer.name} calls $${callAmount}`);
						this.updateUI();
						this.updateOpponentUI();
					} else {
						// Can't afford to call, fold instead
						this.players[this.currentPlayerIndex] = foldPlayer(currentPlayer);
						this.updateGameStatus(`${currentPlayer.name} folds`);
					}
					break;

				case 'raise': {
					const raiseAmount = decision.amount || this.minimumBet;
					const totalBet = highestBet + raiseAmount;
					const amountToAdd = totalBet - currentPlayer.currentBet;

					if (amountToAdd <= currentPlayer.chips) {
						this.players[this.currentPlayerIndex] = placeBet(currentPlayer, amountToAdd);
						this.lastRaiseAmount = raiseAmount;
						this.minimumBet = raiseAmount;
						this.pot = calculatePot(this.players);
						this.updateGameStatus(`${currentPlayer.name} raises $${raiseAmount}`);
						this.updateUI();
						this.updateOpponentUI();
					} else {
						// Can't afford to raise, call instead
						if (callAmount > 0 && callAmount <= currentPlayer.chips) {
							this.players[this.currentPlayerIndex] = placeBet(currentPlayer, callAmount);
							this.pot = calculatePot(this.players);
							this.updateGameStatus(`${currentPlayer.name} calls $${callAmount}`);
							this.updateUI();
							this.updateOpponentUI();
						} else {
							this.players[this.currentPlayerIndex] = foldPlayer(currentPlayer);
							this.updateGameStatus(`${currentPlayer.name} folds`);
						}
					}
					break;
				}

				default:
					break;
			}

			this.advanceTurn();
		}

		private advanceTurn() {
			// Check if betting round is complete
			if (isBettingRoundComplete(this.players)) {
				// Move to next phase
				setTimeout(() => this.nextPhase(), 1000);
				return;
			}

			// Move to next player
			this.currentPlayerIndex = getNextPlayerIndex(this.players, this.currentPlayerIndex);

			if (this.currentPlayerIndex === 0) {
				this.updateGameStatus('Your turn!');
			} else {
				this.updateGameStatus(`Waiting for ${this.players[this.currentPlayerIndex].name}...`);
				this.processAITurn();
			}
		}

		private getPlayerPosition(player: Player): 'early' | 'middle' | 'late' {
			const dealerIndex = this.dealerIndex;
			const playerIndex = this.players.findIndex((p) => p.id === player.id);
			const positionFromDealer =
				(playerIndex - dealerIndex + this.players.length) % this.players.length;

			if (positionFromDealer <= 1) {
				return 'early';
			} else if (positionFromDealer === 2) {
				return 'middle';
			} else {
				return 'late';
			}
		}

		private getSuitSymbol(suit: Suit): string {
			const symbols = {
				hearts: '‚ô•',
				diamonds: '‚ô¶',
				clubs: '‚ô£',
				spades: '‚ô†',
			};
			return symbols[suit];
		}

		private evaluateHand() {
			const strengthEl = document.getElementById('hand-strength');
			if (!strengthEl) return;

			const humanPlayer = this.players[0];
			if (!humanPlayer) return;

			const allCards = [...humanPlayer.hand, ...this.communityCards];
			if (allCards.length < 2) {
				strengthEl.textContent = '--';
				return;
			}

			// Simplified hand evaluation
			const values = allCards.map((c) => c.value);
			const suits = allCards.map((c) => c.suit);

			const valueCounts: Record<string, number> = {};
			values.forEach((v) => (valueCounts[v] = (valueCounts[v] || 0) + 1));

			const counts = Object.values(valueCounts).sort((a, b) => b - a);
			const isFlush = suits.every((s) => s === suits[0]) && suits.length >= 5;

			if (counts[0] === 4) strengthEl.textContent = 'Four of a Kind';
			else if (counts[0] === 3 && counts[1] === 2) strengthEl.textContent = 'Full House';
			else if (isFlush) strengthEl.textContent = 'Flush';
			else if (counts[0] === 3) strengthEl.textContent = 'Three of a Kind';
			else if (counts[0] === 2 && counts[1] === 2) strengthEl.textContent = 'Two Pair';
			else if (counts[0] === 2) strengthEl.textContent = 'Pair';
			else strengthEl.textContent = 'High Card';
		}

		private updateUI() {
			document.getElementById('pot-amount')!.textContent = `$${this.pot}`;
			const humanPlayer = this.players[0];
			if (humanPlayer) {
				document.getElementById('current-bet')!.textContent = `$${humanPlayer.currentBet}`;
				// Update player balance in header
				const balanceEl = document.querySelector(
					'.bg-slate-800.px-6.py-3 .text-2xl.font-bold.text-yellow-400',
				);
				if (balanceEl) {
					balanceEl.textContent = `$${humanPlayer.chips}`;
				}
			}
		}

		private updateGameStatus(message: string) {
			document.getElementById('game-status')!.textContent = message;
		}

		private setAiButtonState(options: { loading?: boolean; disabled?: boolean } = {}) {
			const button = document.getElementById('btn-ai-move');
			if (!(button instanceof HTMLButtonElement)) {
				return;
			}

			if (!button.dataset.originalLabel) {
				button.dataset.originalLabel = button.textContent ?? 'Ask AI Rival';
			}

			if (typeof options.disabled === 'boolean') {
				button.disabled = options.disabled;
			}

			if (options.loading) {
				button.textContent = 'Thinking‚Ä¶';
				button.classList.add('animate-pulse');
			} else {
				button.textContent = button.dataset.originalLabel ?? 'Ask AI Rival';
				button.classList.remove('animate-pulse');
			}
		}

		private updateAiStatus(message?: string, tone: 'neutral' | 'success' | 'error' = 'neutral') {
			const statusEl = document.getElementById('ai-rival-status');
			if (!statusEl) return;

			let text = message;
			let resolvedTone = tone;

			if (!text) {
				if (!this.aiSettings) {
					text = 'AI rival not configured.';
					resolvedTone = 'error';
				} else {
					const providerLabel =
						this.aiSettings.provider === 'openai'
							? 'OpenAI GPT-4o'
							: `Gemini ${this.aiSettings.model}`;
					const hasKey = Boolean(this.getAiKey(this.aiSettings));
					if (hasKey) {
						text = `Ready with ${providerLabel}`;
						resolvedTone = 'success';
					} else {
						text = `Missing ${this.aiSettings.provider === 'openai' ? 'OpenAI' : 'Gemini'} API key`;
						resolvedTone = 'error';
					}
				}
			}

			statusEl.textContent = text;
			statusEl.classList.remove('text-slate-300', 'text-emerald-400', 'text-rose-400');

			if (resolvedTone === 'success') {
				statusEl.classList.add('text-emerald-400');
			} else if (resolvedTone === 'error') {
				statusEl.classList.add('text-rose-400');
			} else {
				statusEl.classList.add('text-slate-300');
			}
		}

		private getAiKey(settings: AiSettings | null): string | null {
			if (!settings) return null;
			if (settings.provider === 'openai') {
				return settings.openaiApiKey ?? null;
			}
			if (settings.provider === 'gemini') {
				return settings.geminiApiKey ?? null;
			}
			return null;
		}

		private async loadAiSettings() {
			this.updateAiStatus('Loading rival settings‚Ä¶', 'neutral');
			try {
				const response = await fetch('/api/profile/llm-settings');
				if (!response.ok) {
					throw new Error(`Unexpected status ${response.status}`);
				}
				const data = await response.json();
				const settings = data?.settings;
				if (
					settings &&
					(settings.provider === 'openai' || settings.provider === 'gemini') &&
					typeof settings.model === 'string'
				) {
					this.aiSettings = {
						provider: settings.provider,
						model: settings.model,
						openaiApiKey: typeof settings.openaiApiKey === 'string' ? settings.openaiApiKey : null,
						geminiApiKey: typeof settings.geminiApiKey === 'string' ? settings.geminiApiKey : null,
					};
					const hasKey = Boolean(this.getAiKey(this.aiSettings));
					this.setAiButtonState({ disabled: !hasKey });
					this.updateAiStatus();
				} else {
					this.aiSettings = null;
					this.setAiButtonState({ disabled: true });
					this.updateAiStatus('No AI rival settings stored yet.', 'error');
				}
			} catch (error) {
				console.error('Failed to load AI rival settings:', error);
				this.aiSettings = null;
				this.setAiButtonState({ disabled: true });
				this.updateAiStatus('Unable to load rival settings.', 'error');
			}
		}

		private formatCard(card: Card) {
			return `${card.value}${this.getSuitSymbol(card.suit)}`;
		}

		private formatCards(cards: Card[]) {
			return cards.length ? cards.map((card) => this.formatCard(card)).join(', ') : 'None';
		}

		private buildPrompt() {
			const phaseLabel = this.gamePhase.toUpperCase();
			const humanPlayer = this.players[0];
			const playerCards = this.formatCards(humanPlayer?.hand || []);
			const communityCards = this.communityCards.length
				? this.formatCards(this.communityCards)
				: 'Not revealed yet';

			const highestBet = getHighestBet(this.players);
			const callAmount = humanPlayer ? getCallAmount(humanPlayer, highestBet) : 0;

			return `You are an AI poker rival advising the user on Texas Hold'em strategy.
Game phase: ${phaseLabel}
Player hole cards: ${playerCards}
Community cards: ${communityCards}
Pot size: $${this.pot}
Current bet to match: $${callAmount}

Respond with a JSON object describing your recommended move.
Use the shape {"move":"fold|check|call|raise","amount":number?}. Amount is required only for raises.
Keep the JSON as the only output.`;
		}

		private async requestAiMove() {
			const settings = this.aiSettings;
			const apiKey = this.getAiKey(settings);
			if (!settings || !apiKey) {
				this.updateAiStatus('AI rival not ready. Check your profile settings.', 'error');
				this.setAiButtonState({ disabled: true });
				return;
			}

			this.setAiButtonState({ loading: true, disabled: true });
			this.updateAiStatus('Consulting the rival‚Ä¶', 'neutral');

			try {
				const prompt = this.buildPrompt();
				let rawResponse = '';

				if (settings.provider === 'openai') {
					rawResponse = await this.callOpenAi(prompt, settings.model, apiKey);
				} else {
					rawResponse = await this.callGemini(prompt, settings.model, apiKey);
				}

				const move = this.parseAiMove(rawResponse);
				this.applyAiMove(move);

				const stillHasKey = Boolean(this.getAiKey(this.aiSettings));
				this.setAiButtonState({ loading: false, disabled: !stillHasKey });
			} catch (error) {
				console.error('AI rival failed to respond:', error);
				this.updateAiStatus('Rival could not decide. Try again.', 'error');
				const stillHasKey = Boolean(this.getAiKey(this.aiSettings));
				this.setAiButtonState({ loading: false, disabled: !stillHasKey });
			}
		}

		private async callOpenAi(prompt: string, model: string, apiKey: string) {
			const response = await fetch('https://api.openai.com/v1/chat/completions', {
				method: 'POST',
				headers: {
					'content-type': 'application/json',
					authorization: `Bearer ${apiKey}`,
				},
				body: JSON.stringify({
					model,
					messages: [
						{
							role: 'system',
							content:
								'You are an elite poker rival helping determine the next move. Answer in JSON only.',
						},
						{ role: 'user', content: prompt },
					],
					temperature: 0.6,
				}),
			});

			const data = await response.json();
			if (!response.ok) {
				const message =
					typeof data?.error?.message === 'string'
						? data.error.message
						: `OpenAI request failed with status ${response.status}`;
				throw new Error(message);
			}

			return (
				data?.choices?.[0]?.message?.content ?? JSON.stringify({ move: 'check', amount: null })
			);
		}

		private async callGemini(prompt: string, model: string, apiKey: string) {
			const response = await fetch(
				`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`,
				{
					method: 'POST',
					headers: {
						'content-type': 'application/json',
					},
					body: JSON.stringify({
						generationConfig: {
							temperature: 0.6,
						},
						contents: [
							{
								role: 'user',
								parts: [
									{
										text: `You are an elite poker rival helping determine the next move. Answer in JSON only.\n${prompt}`,
									},
								],
							},
						],
					}),
				},
			);

			const data = await response.json();
			if (!response.ok) {
				const message =
					data?.error?.message ??
					data?.error ??
					`Gemini request failed with status ${response.status}`;
				throw new Error(typeof message === 'string' ? message : 'Unknown Gemini error');
			}

			const text = data?.candidates?.[0]?.content?.parts
				?.map((part: { text?: string }) => part.text ?? '')
				.join('')
				.trim();

			return text || JSON.stringify({ move: 'check', amount: null });
		}

		private parseAiMove(raw: string): AiMove {
			const source = typeof raw === 'string' ? raw.trim() : '';
			let payload = source;

			const jsonMatch = source.match(/\{[\s\S]*\}/);
			if (jsonMatch) {
				payload = jsonMatch[0];
			}

			let parsed: Record<string, unknown> | null = null;

			try {
				parsed = JSON.parse(payload);
			} catch (_error) {
				// ignore parse error and fallback to heuristics
			}

			let move: AiMoveType | null = null;
			let amount: number | null = null;

			if (parsed && typeof parsed === 'object') {
				const rawMove = parsed.move;
				if (typeof rawMove === 'string') {
					const normalized = rawMove.toLowerCase();
					if (
						normalized === 'fold' ||
						normalized === 'check' ||
						normalized === 'call' ||
						normalized === 'raise'
					) {
						move = normalized;
					}
				}

				const rawAmount = parsed.amount;
				if (rawAmount !== undefined && rawAmount !== null) {
					const attempt = Number(rawAmount);
					if (!Number.isNaN(attempt)) {
						amount = attempt;
					}
				}
			}

			if (!move) {
				if (/fold/i.test(source)) move = 'fold';
				else if (/check/i.test(source)) move = 'check';
				else if (/call/i.test(source)) move = 'call';
				else if (/raise/i.test(source)) move = 'raise';
				else move = 'check';
			}

			if (move === 'raise' && (amount === null || Number.isNaN(amount))) {
				const amountMatch = source.match(/(\d{2,4})/);
				if (amountMatch) {
					amount = Number(amountMatch[1]);
				}
			}

			return {
				move,
				amount: Number.isFinite(amount) ? amount : null,
				raw: source,
			};
		}

		private clampRaise(amount: number | null) {
			if (amount === null || Number.isNaN(amount)) {
				return null;
			}
			const clamped = Math.max(10, Math.min(Math.round(amount), 1000));
			return clamped;
		}

		private highlightSuggestedMove(move: AiMoveType | null) {
			const buttonMap: Record<AiMoveType, string> = {
				fold: 'btn-fold',
				check: 'btn-check',
				call: 'btn-call',
				raise: 'btn-raise',
			};

			(Object.keys(buttonMap) as AiMoveType[]).forEach((key) => {
				const el = document.getElementById(buttonMap[key]);
				if (!(el instanceof HTMLButtonElement)) return;
				el.classList.remove('ring-2', 'ring-offset-2', 'ring-yellow-400');
				if (move && key === move) {
					el.classList.add('ring-2', 'ring-offset-2', 'ring-yellow-400');
				}
			});
		}

		private applyAiMove(move: AiMove) {
			this.highlightSuggestedMove(move.move);

			let description = '';
			if (move.move === 'fold') {
				description = 'fold';
			} else if (move.move === 'check') {
				description = 'check';
			} else if (move.move === 'call') {
				description = 'call';
			} else if (move.move === 'raise') {
				const raise = this.clampRaise(move.amount);
				if (raise !== null) {
					const slider = document.getElementById('bet-slider');
					const betLabel = document.getElementById('bet-amount');
					if (slider instanceof HTMLInputElement) {
						slider.value = String(raise);
					}
					if (betLabel) {
						betLabel.textContent = `$${raise}`;
					}
					description = `raise $${raise}`;
				} else {
					description = 'raise';
				}
			}

			this.updateAiStatus(`Suggested move: ${description.toUpperCase()}`, 'success');
			this.updateGameStatus(`AI rival recommends you ${description || move.move}.`);
		}

		private nextPhase() {
			// Reset current bets for new betting round
			this.players = this.players.map(resetCurrentBets);

			if (this.gamePhase === 'preflop') {
				this.gamePhase = 'flop';
				this.bettingRound = 'flop';
				this.communityCards.push(this.drawCard(), this.drawCard(), this.drawCard());
				this.updateGameStatus('Flop revealed!');
			} else if (this.gamePhase === 'flop') {
				this.gamePhase = 'turn';
				this.bettingRound = 'turn';
				this.communityCards.push(this.drawCard());
				this.updateGameStatus('Turn card revealed!');
			} else if (this.gamePhase === 'turn') {
				this.gamePhase = 'river';
				this.bettingRound = 'river';
				this.communityCards.push(this.drawCard());
				this.updateGameStatus('River card revealed!');
			} else if (this.gamePhase === 'river') {
				this.gamePhase = 'showdown';
				this.bettingRound = null;
				// Simple showdown: last player standing wins (proper hand comparison in Phase 4)
				const activePlayers = getActivePlayers(this.players);
				if (activePlayers.length === 1) {
					const winner = activePlayers[0];
					this.players[winner.id] = awardChips(winner, this.pot);
					this.updateGameStatus(`${winner.name} wins $${this.pot}! üéâ`);
				} else {
					// For now, just award to first active player (will be replaced with proper hand comparison)
					const winner = activePlayers[0];
					this.players[winner.id] = awardChips(winner, this.pot);
					this.updateGameStatus(`${winner.name} wins! üéâ`);
				}
				this.pot = 0;
				this.updateUI();
				this.updateOpponentUI();
				// Auto-deal new hand after 3 seconds
				setTimeout(() => this.dealNewHand(), 3000);
				return;
			}

			// Start new betting round from dealer
			this.currentPlayerIndex = (this.dealerIndex + 1) % this.players.length;
			this.currentPlayerIndex = getNextPlayerIndex(this.players, this.dealerIndex);

			this.renderCommunityCards();
			this.evaluateHand();
			this.updateUI();

			if (this.currentPlayerIndex === 0) {
				this.updateGameStatus('Your turn!');
			} else {
				this.updateGameStatus(`Waiting for ${this.players[this.currentPlayerIndex].name}...`);
				this.processAITurn();
			}
		}

		private attachEventListeners() {
			document.getElementById('btn-deal')?.addEventListener('click', () => this.dealNewHand());

			document.getElementById('btn-fold')?.addEventListener('click', () => {
				if (this.isProcessingAction || this.currentPlayerIndex !== 0) return;
				this.isProcessingAction = true;

				try {
					this.players[0] = foldPlayer(this.players[0]);
					this.updateUI();
					this.updateGameStatus('You folded');
				} finally {
					this.isProcessingAction = false;
				}
				this.advanceTurn();
			});

			document.getElementById('btn-check')?.addEventListener('click', () => {
				if (this.isProcessingAction || this.currentPlayerIndex !== 0) return;
				const highestBet = getHighestBet(this.players);
				if (this.players[0].currentBet < highestBet) return; // Can't check if there's a bet

				this.isProcessingAction = true;
				try {
					this.updateGameStatus('You checked');
				} finally {
					this.isProcessingAction = false;
				}
				this.advanceTurn();
			});

			document.getElementById('btn-call')?.addEventListener('click', () => {
				if (this.isProcessingAction || this.currentPlayerIndex !== 0) return;
				this.isProcessingAction = true;

				try {
					const highestBet = getHighestBet(this.players);
					const callAmount = getCallAmount(this.players[0], highestBet);

					if (callAmount > 0) {
						this.players[0] = placeBet(this.players[0], callAmount);
						this.pot = calculatePot(this.players);
						this.updateUI();
						this.updateGameStatus(`You called $${callAmount}`);
					}
				} finally {
					this.isProcessingAction = false;
				}
				this.advanceTurn();
			});

			document.getElementById('btn-raise')?.addEventListener('click', () => {
				if (this.isProcessingAction || this.currentPlayerIndex !== 0) return;
				this.isProcessingAction = true;

				try {
					const raiseAmount = parseInt(
						(document.getElementById('bet-slider') as HTMLInputElement).value,
					);
					const highestBet = getHighestBet(this.players);
					const totalBet = highestBet + raiseAmount;
					const amountToAdd = totalBet - this.players[0].currentBet;
					this.players[0] = placeBet(this.players[0], amountToAdd);
					this.lastRaiseAmount = raiseAmount;
					this.minimumBet = raiseAmount;
					this.pot = calculatePot(this.players);
					this.updateUI();
					this.updateGameStatus(`You raised $${raiseAmount}`);
				} finally {
					this.isProcessingAction = false;
				}
				this.advanceTurn();
			});

			const betSlider = document.getElementById('bet-slider') as HTMLInputElement;
			const betAmount = document.getElementById('bet-amount');
			betSlider?.addEventListener('input', (e) => {
				const value = (e.target as HTMLInputElement).value;
				if (betAmount) betAmount.textContent = `$${value}`;
			});

			// Quick bet chips
			document.querySelectorAll('.quick-bet-chip').forEach((btn) => {
				btn.addEventListener('click', (e) => {
					const amount = (e.currentTarget as HTMLElement).dataset.amount;
					if (amount && betSlider) {
						betSlider.value = amount;
						if (betAmount) betAmount.textContent = `$${amount}`;
					}
				});
			});

			document.getElementById('btn-ai-move')?.addEventListener('click', () => {
				void this.requestAiMove();
			});
		}
	}

	// Initialize game when DOM is loaded
	if (typeof window !== 'undefined') {
		new PokerGame();
	}
</script>
