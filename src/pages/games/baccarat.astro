---
import CasinoLayout from '../../layouts/casino.astro';
import PokerChip from '../../components/PokerChip.astro';
import BaccaratCardContainer from '../../components/BaccaratCardContainer.astro';

const user = Astro.locals.user;

if (!user) {
	return Astro.redirect('/signin');
}

// Use nullish coalescing to preserve zero balance
const initialBalance = user.chipBalance ?? 1000;
---

<CasinoLayout title="Baccarat - Arcturus Casino">
	<div
		id="baccarat-root"
		data-user-id={user.id}
		data-initial-balance={initialBalance}
		class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8"
	>
		<!-- Game Header -->
		<div class="flex items-center justify-between mb-6">
			<div>
				<a
					href="/games"
					class="text-slate-400 hover:text-yellow-400 transition-colors mb-2 inline-block"
				>
					‚Üê Back to Games
				</a>
				<h1
					class="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-amber-500"
				>
					Baccarat
				</h1>
			</div>
			<div class="flex items-center gap-4">
				<div class="bg-slate-800 px-4 py-2 rounded-lg border border-slate-600 text-sm">
					<span class="text-slate-400">Shoe:</span>
					<span id="shoe-count" class="text-white ml-1">416 cards</span>
				</div>
				<div class="bg-slate-800 px-6 py-3 rounded-lg border border-yellow-500/30">
					<div class="text-xs text-slate-400 mb-1">Your Balance</div>
					<div class="text-2xl font-bold text-yellow-400" id="chip-balance">
						${initialBalance.toLocaleString()}
					</div>
				</div>
			</div>
		</div>

		<!-- Main Game Area -->
		<div class="grid grid-cols-1 lg:grid-cols-4 gap-6">
			<!-- Game Table (3 columns) -->
			<div class="lg:col-span-3">
				<!-- Baccarat Table -->
				<div class="felt-table rounded-3xl p-6 mb-6 relative" style="min-height: 420px;">
					<!-- Game Status Message -->
					<div
						id="game-status"
						class="hidden absolute top-4 left-1/2 -translate-x-1/2 text-lg font-semibold text-yellow-400 bg-slate-900/90 backdrop-blur-sm px-6 py-2 rounded-full border border-yellow-500/50 z-10"
					>
						Place your bets
					</div>

					<!-- Banker Area -->
					<div id="banker-hand" class="mb-8">
						<div class="text-center">
							<div class="text-sm text-red-400 uppercase tracking-wider mb-2 font-semibold">
								Banker
							</div>
							<BaccaratCardContainer id="banker-cards" maxCards={3} />
							<div class="hand-value text-xl font-bold text-white mt-2" id="banker-value"></div>
						</div>
					</div>

					<!-- Divider -->
					<div class="border-t border-slate-600/50 my-6"></div>

					<!-- Player Area -->
					<div id="player-hand" class="mb-6">
						<div class="text-center">
							<div class="text-sm text-blue-400 uppercase tracking-wider mb-2 font-semibold">
								Player
							</div>
							<BaccaratCardContainer id="player-cards" maxCards={3} />
							<div class="hand-value text-xl font-bold text-white mt-2" id="player-value"></div>
						</div>
					</div>

					<!-- Round Result Overlay -->
					<div
						id="round-result"
						class="absolute inset-0 bg-slate-900/95 backdrop-blur-sm rounded-3xl flex items-center justify-center z-20 hidden"
					>
						<div class="text-center p-8">
							<div class="result-winner text-4xl font-bold text-yellow-400 mb-4"></div>
							<div class="result-scores text-xl text-slate-300 mb-4"></div>
							<div class="result-pairs text-lg text-green-400 mb-4"></div>
							<div class="result-bets space-y-2 mb-6"></div>
							<button id="new-round-button" class="btn-gold px-8 py-3 rounded-lg font-bold text-lg">
								NEW ROUND
							</button>
						</div>
					</div>
				</div>

				<!-- Betting Area -->
				<div id="betting-area" class="bg-slate-900 rounded-xl p-6 border border-slate-700">
					<h3 class="text-lg font-bold text-white mb-4 text-center">Place Your Bets</h3>

					<!-- Main Bets -->
					<div class="grid grid-cols-3 gap-4 mb-4">
						<!-- Player Bet -->
						<div
							data-bet-type="player"
							class="bet-area bg-blue-900/30 hover:bg-blue-900/50 border-2 border-blue-500/30 hover:border-blue-500 rounded-xl p-4 cursor-pointer transition-all text-center"
						>
							<div class="text-blue-400 font-bold text-lg mb-1">PLAYER</div>
							<div class="text-slate-400 text-sm">Pays 1:1</div>
							<div class="bet-amount text-yellow-400 font-bold mt-2 h-6"></div>
						</div>

						<!-- Tie Bet -->
						<div
							data-bet-type="tie"
							class="bet-area bg-green-900/30 hover:bg-green-900/50 border-2 border-green-500/30 hover:border-green-500 rounded-xl p-4 cursor-pointer transition-all text-center"
						>
							<div class="text-green-400 font-bold text-lg mb-1">TIE</div>
							<div class="text-slate-400 text-sm">Pays 8:1</div>
							<div class="bet-amount text-yellow-400 font-bold mt-2 h-6"></div>
						</div>

						<!-- Banker Bet -->
						<div
							data-bet-type="banker"
							class="bet-area bg-red-900/30 hover:bg-red-900/50 border-2 border-red-500/30 hover:border-red-500 rounded-xl p-4 cursor-pointer transition-all text-center"
						>
							<div class="text-red-400 font-bold text-lg mb-1">BANKER</div>
							<div class="text-slate-400 text-sm">Pays 0.95:1</div>
							<div class="bet-amount text-yellow-400 font-bold mt-2 h-6"></div>
						</div>
					</div>

					<!-- Side Bets -->
					<div class="grid grid-cols-2 gap-4 mb-6">
						<!-- Player Pair -->
						<div
							data-bet-type="playerPair"
							class="bet-area bg-purple-900/30 hover:bg-purple-900/50 border-2 border-purple-500/30 hover:border-purple-500 rounded-xl p-3 cursor-pointer transition-all text-center"
						>
							<div class="text-purple-400 font-bold mb-1">PLAYER PAIR</div>
							<div class="text-slate-400 text-xs">Pays 11:1</div>
							<div class="bet-amount text-yellow-400 font-bold mt-1 h-5 text-sm"></div>
						</div>

						<!-- Banker Pair -->
						<div
							data-bet-type="bankerPair"
							class="bet-area bg-purple-900/30 hover:bg-purple-900/50 border-2 border-purple-500/30 hover:border-purple-500 rounded-xl p-3 cursor-pointer transition-all text-center"
						>
							<div class="text-purple-400 font-bold mb-1">BANKER PAIR</div>
							<div class="text-slate-400 text-xs">Pays 11:1</div>
							<div class="bet-amount text-yellow-400 font-bold mt-1 h-5 text-sm"></div>
						</div>
					</div>

					<!-- Chip Selection -->
					<div class="flex justify-center gap-3 mb-4">
						<button class="chip-select hover:scale-110 transition-transform" data-amount="10">
							<PokerChip value={10} color="gold" />
						</button>
						<button class="chip-select hover:scale-110 transition-transform" data-amount="25">
							<PokerChip value={25} color="red" />
						</button>
						<button class="chip-select hover:scale-110 transition-transform" data-amount="50">
							<PokerChip value={50} color="blue" />
						</button>
						<button class="chip-select hover:scale-110 transition-transform" data-amount="100">
							<PokerChip value={100} color="green" />
						</button>
						<button class="chip-select hover:scale-110 transition-transform" data-amount="500">
							<PokerChip value={500} color="black" />
						</button>
					</div>

					<!-- Total Bet & Actions -->
					<div class="flex items-center justify-between">
						<div>
							<span class="text-slate-400">Total Bet:</span>
							<span id="total-bet" class="text-yellow-400 font-bold ml-2">$0</span>
						</div>
						<div class="flex gap-3">
							<button
								id="clear-bets-button"
								class="px-4 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-lg transition-colors"
							>
								Clear
							</button>
							<button
								id="deal-button"
								disabled
								class="btn-gold px-8 py-2 rounded-lg font-bold disabled:opacity-50 disabled:cursor-not-allowed"
							>
								DEAL
							</button>
						</div>
					</div>
				</div>
			</div>

			<!-- Sidebar (1 column) -->
			<div class="space-y-6">
				<!-- Scoreboard -->
				<div class="bg-slate-900 rounded-xl p-4 border border-slate-700">
					<h3 class="text-sm font-bold text-slate-400 uppercase tracking-wider mb-3">History</h3>
					<div id="scoreboard" class="flex flex-wrap gap-1 min-h-[60px]">
						<span class="text-neutral-500">No history yet</span>
					</div>
					<div class="mt-3 pt-3 border-t border-slate-700">
						<div class="grid grid-cols-3 gap-2 text-center text-xs">
							<div>
								<div class="text-blue-400 font-bold" id="stat-player">0%</div>
								<div class="text-slate-500">Player</div>
							</div>
							<div>
								<div class="text-green-400 font-bold" id="stat-tie">0%</div>
								<div class="text-slate-500">Tie</div>
							</div>
							<div>
								<div class="text-red-400 font-bold" id="stat-banker">0%</div>
								<div class="text-slate-500">Banker</div>
							</div>
						</div>
					</div>
				</div>

				<!-- Active Bets -->
				<div class="bg-slate-900 rounded-xl p-4 border border-slate-700">
					<h3 class="text-sm font-bold text-slate-400 uppercase tracking-wider mb-3">Your Bets</h3>
					<div id="active-bets" class="space-y-2 min-h-[40px]">
						<span class="text-neutral-500">No bets placed</span>
					</div>
				</div>

				<!-- Payouts Reference -->
				<div class="bg-slate-900 rounded-xl p-4 border border-slate-700">
					<h3 class="text-sm font-bold text-slate-400 uppercase tracking-wider mb-3">Payouts</h3>
					<div class="space-y-2 text-sm">
						<div class="flex justify-between">
							<span class="text-blue-400">Player</span>
							<span class="text-slate-300">1:1</span>
						</div>
						<div class="flex justify-between">
							<span class="text-red-400">Banker</span>
							<span class="text-slate-300">0.95:1</span>
						</div>
						<div class="flex justify-between">
							<span class="text-green-400">Tie</span>
							<span class="text-slate-300">8:1</span>
						</div>
						<div class="flex justify-between">
							<span class="text-purple-400">Pairs</span>
							<span class="text-slate-300">11:1</span>
						</div>
					</div>
				</div>
			</div>
		</div>

		<!-- Insufficient Chips Overlay -->
		<div
			id="insufficient-chips-overlay"
			class="fixed inset-0 bg-slate-900/95 backdrop-blur-sm z-50 flex items-center justify-center hidden"
		>
			<div class="bg-slate-800 rounded-xl p-8 border border-red-500/50 max-w-md text-center">
				<div class="text-5xl mb-4">üí∏</div>
				<h2 class="text-2xl font-bold text-white mb-2">Insufficient Chips</h2>
				<p class="text-slate-400 mb-6">You don't have enough chips to continue playing.</p>
				<a href="/games" class="btn-gold px-8 py-3 rounded-lg font-bold inline-block">
					Return to Lobby
				</a>
			</div>
		</div>
	</div>

	<!-- Achievement Toast Notification -->
	<div
		id="achievement-toast"
		data-testid="achievement-toast"
		role="status"
		aria-live="polite"
		aria-atomic="true"
		class="fixed bottom-4 right-4 bg-gradient-to-r from-yellow-500 to-amber-500 text-slate-900 px-5 py-4 rounded-xl shadow-2xl flex items-center gap-3 transition-all duration-300 opacity-0 pointer-events-none translate-y-4"
		style="z-index: 9999;"
	>
		<span id="achievement-icon" data-testid="achievement-icon" class="text-3xl">üèÜ</span>
		<div>
			<p class="text-xs font-semibold uppercase tracking-wider opacity-80">Achievement Unlocked</p>
			<p id="achievement-name" data-testid="achievement-name" class="font-bold text-lg">
				Achievement Name
			</p>
		</div>
	</div>
</CasinoLayout>

<style>
	.felt-table {
		background: linear-gradient(135deg, #0d4a35 0%, #0a3829 50%, #073020 100%);
		box-shadow:
			inset 0 0 100px rgba(0, 0, 0, 0.3),
			0 10px 40px rgba(0, 0, 0, 0.5);
	}

	.card-placeholder {
		width: 60px;
		height: 84px;
		background: rgba(255, 255, 255, 0.05);
		border: 2px dashed rgba(255, 255, 255, 0.1);
		border-radius: 8px;
	}

	.hand-cards .card {
		width: 60px;
		height: 84px;
		background: white;
		border-radius: 8px;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		font-size: 1.25rem;
		font-weight: bold;
		box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
		animation: dealCard 0.3s ease-out;
	}

	@keyframes dealCard {
		from {
			opacity: 0;
			transform: translateY(-20px) scale(0.8);
		}
		to {
			opacity: 1;
			transform: translateY(0) scale(1);
		}
	}

	.card-dealing {
		animation: dealCard 0.3s ease-out;
	}

	.bet-area {
		transition: all 0.2s ease;
	}

	.bet-area:hover {
		transform: translateY(-2px);
	}

	.bet-area-active {
		border-color: rgba(234, 179, 8, 0.8) !important;
		box-shadow: 0 0 20px rgba(234, 179, 8, 0.3);
	}

	.betting-disabled {
		opacity: 0.5;
		pointer-events: none;
	}

	.scoreboard-dot {
		width: 24px;
		height: 24px;
		border-radius: 50%;
		display: inline-flex;
		align-items: center;
		justify-content: center;
		font-size: 10px;
		font-weight: bold;
		color: white;
	}

	.bet-chip {
		display: inline-flex;
		align-items: center;
		gap: 8px;
		background: rgba(234, 179, 8, 0.1);
		border: 1px solid rgba(234, 179, 8, 0.3);
		padding: 4px 12px;
		border-radius: 20px;
	}

	.bet-result {
		display: flex;
		justify-content: space-between;
		gap: 16px;
		padding: 8px 16px;
		background: rgba(255, 255, 255, 0.05);
		border-radius: 8px;
	}

	.chip-select {
		transition: transform 0.2s ease;
	}

	.chip-select.selected {
		transform: scale(1.2);
		filter: drop-shadow(0 0 10px rgba(234, 179, 8, 0.5));
	}
</style>

<script>
	import { BaccaratGame } from '../../lib/baccarat/BaccaratGame';
	import { getHandValue } from '../../lib/baccarat/handEvaluator';
	import type { BetType, Card, Hand, RoundOutcome } from '../../lib/baccarat/types';
	import {
		clearChildren,
		createTextSpan,
		createScoreboardDot,
		createBetChip,
		createBetResult,
	} from '../../lib/dom-utils';
	import {
		resolveBaccaratSyncState,
	} from '../../lib/baccarat/balance-sync-state';
	import { initAchievementToast } from '../../lib/achievement-toast';
	import { setSlotState } from '../../lib/card-slot-utils';

	// Get initial data
	const root = document.getElementById('baccarat-root');
	if (!root) {
		throw new Error('Baccarat root element not found');
	}
	const initialBalance = Number(root.dataset.initialBalance ?? 1000);

	// Initialize game
	const game = new BaccaratGame({
		initialBalance,
		settings: {
			minBet: 10,
			maxBet: 5000,
			startingChips: initialBalance,
			animationSpeed: 'normal',
			llmEnabled: false,
			soundEnabled: true,
		},
	});

	// State
	let selectedChipAmount = 50;

	// Track pending stats from rounds where sync is delayed (e.g., rate-limited)
	// This prevents stats drift when multiple rounds are played before sync succeeds
	let pendingStats = {
		winsIncrement: 0,
		lossesIncrement: 0,
		handsIncrement: 0,
		biggestWinCandidate: undefined as number | undefined,
	};
	let syncPending = false;

	// Track pending retry timer to cancel stale retries before starting new sync
	let pendingRetryTimer: ReturnType<typeof setTimeout> | null = null;

	// Concurrency guard: prevents overlapping performChipUpdate executions
	let isSyncInProgress = false;

	// DOM Elements
	const balanceEl = document.getElementById('chip-balance');
	if (!balanceEl) throw new Error('Baccarat UI elements not found');
	const shoeCountEl = document.getElementById('shoe-count');
	if (!shoeCountEl) throw new Error('Baccarat UI elements not found');
	const totalBetEl = document.getElementById('total-bet');
	if (!totalBetEl) throw new Error('Baccarat UI elements not found');
	const dealButtonEl = document.getElementById('deal-button');
	if (!(dealButtonEl instanceof HTMLButtonElement))
		throw new Error('Baccarat UI elements not found');
	const dealButton = dealButtonEl;
	const clearBetsButton = document.getElementById('clear-bets-button');
	if (!clearBetsButton) throw new Error('Baccarat UI elements not found');
	const newRoundButton = document.getElementById('new-round-button');
	if (!newRoundButton) throw new Error('Baccarat UI elements not found');
	const playerHandEl = document.getElementById('player-hand');
	if (!playerHandEl) throw new Error('Baccarat UI elements not found');
	const bankerHandEl = document.getElementById('banker-hand');
	if (!bankerHandEl) throw new Error('Baccarat UI elements not found');
	const roundResultEl = document.getElementById('round-result');
	if (!roundResultEl) throw new Error('Baccarat UI elements not found');
	const bettingAreaEl = document.getElementById('betting-area');
	if (!bettingAreaEl) throw new Error('Baccarat UI elements not found');
	const activeBetsEl = document.getElementById('active-bets');
	if (!activeBetsEl) throw new Error('Baccarat UI elements not found');
	const scoreboardEl = document.getElementById('scoreboard');
	if (!scoreboardEl) throw new Error('Baccarat UI elements not found');
	const insufficientOverlay = document.getElementById('insufficient-chips-overlay');
	if (!insufficientOverlay) throw new Error('Baccarat UI elements not found');
	const statusEl = document.getElementById('game-status');
	if (!statusEl) throw new Error('Baccarat UI elements not found');

	// Chip selection
	document.querySelectorAll('.chip-select').forEach((btn) => {
		btn.addEventListener('click', () => {
			document.querySelectorAll('.chip-select').forEach((b) => b.classList.remove('selected'));
			btn.classList.add('selected');
			const amountAttr = btn.getAttribute('data-amount');
			if (amountAttr) {
				selectedChipAmount = Number(amountAttr);
			}
		});
	});

	// Select default chip
	document.querySelector('.chip-select[data-amount="50"]')?.classList.add('selected');

	// Bet area clicks
	document.querySelectorAll('[data-bet-type]').forEach((area) => {
		area.addEventListener('click', () => {
			const type = area.getAttribute('data-bet-type') as BetType | null;
			if (!type) return;
			const result = game.placeBet(type, selectedChipAmount);
			if (result.success) {
				updateUI();
			} else {
				showStatus(result.error ?? 'Failed to place bet');
			}
		});
	});

	// Clear bets
	clearBetsButton.addEventListener('click', () => {
		game.clearBets();
		updateUI();
	});

	// Deal
	dealButton.addEventListener('click', async () => {
		if (!game.canDeal()) return;

		// Disable betting
		bettingAreaEl.classList.add('betting-disabled');
		dealButton.disabled = true;
		roundResultEl.classList.add('hidden');
		roundResultEl.classList.remove('flex');

		// Clear hand displays
		renderHand(playerHandEl, { cards: [] }, 'PLAYER', 'blue');
		renderHand(bankerHandEl, { cards: [] }, 'BANKER', 'red');

		showStatus('Dealing...');

		const balanceBeforeRound = game.getBalance();

		// Deal and animate
		const outcome = game.deal();
		if (outcome) {
			const balanceAfterRound = game.getBalance();
			const roundNetDelta = balanceAfterRound - balanceBeforeRound;

			// Update balance/total immediately so tests don't read stale values while animations/network run
			updateUI();

			await animateRound(outcome);
			showResult(outcome);
			await syncBalance(roundNetDelta);

			// Check insufficient chips
			if (game.hasInsufficientChips()) {
				insufficientOverlay.classList.remove('hidden');
				insufficientOverlay.classList.add('flex');
			}
		}

		updateUI();
	});

	// New round
	newRoundButton.addEventListener('click', () => {
		game.newRound();
		roundResultEl.classList.add('hidden');
		roundResultEl.classList.remove('flex');
		bettingAreaEl.classList.remove('betting-disabled');
		renderHand(playerHandEl, { cards: [] }, 'PLAYER', 'blue');
		renderHand(bankerHandEl, { cards: [] }, 'BANKER', 'red');
		hideStatus();
		updateUI();
	});

	// Animation helpers
	async function animateRound(outcome: RoundOutcome) {
		const delay = (ms: number) => new Promise((r) => setTimeout(r, ms));

		// Deal initial 4 cards with animation
		await animateCard(playerHandEl, outcome.playerHand.cards[0], 0);
		await delay(300);
		await animateCard(bankerHandEl, outcome.bankerHand.cards[0], 0);
		await delay(300);
		await animateCard(playerHandEl, outcome.playerHand.cards[1], 1);
		await delay(300);
		await animateCard(bankerHandEl, outcome.bankerHand.cards[1], 1);
		await delay(500);

		// Third cards if present
		if (outcome.playerHand.cards.length > 2) {
			showStatus('Player draws third card');
			await delay(500);
			await animateCard(playerHandEl, outcome.playerHand.cards[2], 2);
			await delay(500);
		}

		if (outcome.bankerHand.cards.length > 2) {
			showStatus('Banker draws third card');
			await delay(500);
			await animateCard(bankerHandEl, outcome.bankerHand.cards[2], 2);
			await delay(500);
		}

		hideStatus();
	}

	async function animateCard(container: HTMLElement, card: Card, position: number) {
		const cardsContainer = container.querySelector('[data-baccarat-card-container]');
		if (!cardsContainer) return;

		const slots = cardsContainer.querySelectorAll('.card-slot');
		const slot = slots[position];
		if (slot) {
			setSlotState(slot, 'card', { rank: card.rank, suit: card.suit });
		}

		await new Promise((r) => setTimeout(r, 300));
	}

	function renderHand(
		container: HTMLElement,
		hand: Hand,
		_label: string,
		_color: 'blue' | 'red' | 'emerald' | 'yellow',
	) {
		const value = hand.cards.length >= 2 ? getHandValue(hand) : '';

		// Update card slots
		const cardsContainer = container.querySelector('[data-baccarat-card-container]');
		if (cardsContainer) {
			const slots = cardsContainer.querySelectorAll('.card-slot');
			slots.forEach((slot, index) => {
				if (index < hand.cards.length) {
					const card = hand.cards[index];
					setSlotState(slot, 'card', { rank: card.rank, suit: card.suit });
				} else if (index < 2) {
					setSlotState(slot, 'placeholder');
				} else {
					setSlotState(slot, 'hidden');
				}
			});
		}

		// Update hand value
		const valueEl = container.querySelector('.hand-value');
		if (valueEl) {
			valueEl.textContent = String(value);
		}
	}

	function showResult(outcome: RoundOutcome) {
		const winnerText =
			outcome.winner === 'player'
				? 'Player Wins!'
				: outcome.winner === 'banker'
					? 'Banker Wins!'
					: 'Tie!';
		const naturalText = outcome.isNatural ? ' (Natural!)' : '';
		const pairText = [
			outcome.playerPair ? 'Player Pair' : null,
			outcome.bankerPair ? 'Banker Pair' : null,
		]
			.filter(Boolean)
			.join(' | ');

		const typeLabelMap: Record<BetType, string> = {
			player: 'Player',
			banker: 'Banker',
			tie: 'Tie',
			playerPair: 'P. Pair',
			bankerPair: 'B. Pair',
		};

		const winnerEl = roundResultEl.querySelector('.result-winner');
		const scoresEl = roundResultEl.querySelector('.result-scores');
		const pairsEl = roundResultEl.querySelector('.result-pairs');
		const betsEl = roundResultEl.querySelector('.result-bets');

		if (winnerEl) {
			winnerEl.textContent = winnerText + naturalText;
		}
		if (scoresEl) {
			scoresEl.textContent = `Player: ${outcome.playerValue} | Banker: ${outcome.bankerValue}`;
		}
		if (pairsEl) {
			pairsEl.textContent = pairText;
		}
		if (betsEl) {
			clearChildren(betsEl);
			outcome.betResults.forEach((result) => {
				const typeLabel = typeLabelMap[result.bet.type];
				betsEl.appendChild(createBetResult(typeLabel, result.outcome, result.payout));
			});
		}
		roundResultEl.classList.remove('hidden');
		roundResultEl.classList.add('flex');

		// Update rendered hands with final values
		renderHand(playerHandEl, outcome.playerHand, 'PLAYER', 'blue');
		renderHand(bankerHandEl, outcome.bankerHand, 'BANKER', 'red');
	}

	function updateUI() {
		const state = game.getState();

		// Balance
		balanceEl.textContent = `$${state.chipBalance.toLocaleString()}`;

		// Shoe count
		shoeCountEl.textContent = `${state.shoeCardsRemaining} cards`;

		// Total bet
		const total = game.getBetTotal();
		totalBetEl.textContent = `$${total}`;

		// Deal button
		dealButton.disabled = !game.canDeal();

		// Active bets display
		clearChildren(activeBetsEl);
		if (state.activeBets.length === 0) {
			activeBetsEl.appendChild(createTextSpan('No bets placed', 'text-neutral-500'));
		} else {
			const betTypeLabelMap: Record<string, string> = {
				player: 'Player',
				banker: 'Banker',
				tie: 'Tie',
				playerPair: 'P. Pair',
				bankerPair: 'B. Pair',
			};
			state.activeBets.forEach((bet) => {
				const typeLabel = betTypeLabelMap[bet.type] || bet.type;
				activeBetsEl.appendChild(createBetChip(typeLabel, bet.amount));
			});
		}

		// Update bet area amounts
		document.querySelectorAll('[data-bet-type]').forEach((area) => {
			const type = area.getAttribute('data-bet-type');
			const bet = state.activeBets.find((b) => b.type === type);
			const amountEl = area.querySelector('.bet-amount');
			if (amountEl) {
				amountEl.textContent = bet ? `$${bet.amount}` : '';
			}
			if (bet) {
				area.classList.add('bet-area-active');
			} else {
				area.classList.remove('bet-area-active');
			}
		});

		// Scoreboard
		clearChildren(scoreboardEl);
		if (state.roundHistory.length === 0) {
			scoreboardEl.appendChild(createTextSpan('No history yet', 'text-neutral-500'));
		} else {
			state.roundHistory.forEach((round) => {
				scoreboardEl.appendChild(createScoreboardDot(round.winner));
			});
		}

		// Stats
		const stats = game.getStatistics();
		const totalRounds = stats.player + stats.banker + stats.tie;
		const getPercent = (count: number) =>
			totalRounds > 0 ? Math.round((count / totalRounds) * 100) : 0;

		const statPlayerEl = document.getElementById('stat-player');
		const statTieEl = document.getElementById('stat-tie');
		const statBankerEl = document.getElementById('stat-banker');

		if (statPlayerEl) {
			statPlayerEl.textContent = `${getPercent(stats.player)}%`;
		}
		if (statTieEl) {
			statTieEl.textContent = `${getPercent(stats.tie)}%`;
		}
		if (statBankerEl) {
			statBankerEl.textContent = `${getPercent(stats.banker)}%`;
		}
	}

	function showStatus(message: string) {
		statusEl.textContent = message;
		statusEl.classList.remove('hidden');
	}

	function hideStatus() {
		statusEl.classList.add('hidden');
	}

	let lastSyncedBalance = initialBalance;

	async function syncBalance(roundNetDelta: number) {
		// Clear any pending retry timer from previous sync attempt to prevent stale deltas
		if (pendingRetryTimer) {
			clearTimeout(pendingRetryTimer);
			pendingRetryTimer = null;
		}

		// Determine outcome from per-round net delta (not aggregated sync delta)
		// Important: Even when roundNetDelta === 0 (push), we need to sync to record stats
		let outcome: 'win' | 'loss' | 'push';
		if (roundNetDelta > 0) {
			outcome = 'win';
		} else if (roundNetDelta < 0) {
			outcome = 'loss';
		} else {
			outcome = 'push';
		}

		// Track stats for this round
		const winsIncrement = outcome === 'win' ? 1 : 0;
		const lossesIncrement = outcome === 'loss' ? 1 : 0;
		const handsIncrement = 1; // Baccarat is always 1 hand per round

		// Flag to track whether current round stats have been included in pendingStats
		let statsIncluded = false;

		const performChipUpdate = async (retryCount = 0) => {
			// Concurrency guard: skip if another performChipUpdate is already in-flight
			if (isSyncInProgress) {
				// Ensure current round stats are still queued for the next sync
				if (!statsIncluded) {
					pendingStats.winsIncrement += winsIncrement;
					pendingStats.lossesIncrement += lossesIncrement;
					pendingStats.handsIncrement += handsIncrement;
					// Track biggest win for this round (positive delta only)
					if (roundNetDelta > 0) {
						pendingStats.biggestWinCandidate = Math.max(
							pendingStats.biggestWinCandidate ?? 0,
							roundNetDelta,
						);
					}
					statsIncluded = true;
					syncPending = true;
				}
				return;
			}
			isSyncInProgress = true;

			try {
				// Clear any pending retry timer from previous retry attempt
				if (pendingRetryTimer) {
					clearTimeout(pendingRetryTimer);
					pendingRetryTimer = null;
				}

				// Recompute delta using current game balance (not stale cached delta)
				// This prevents double-applying deltas when a later round syncs before an earlier retry
				const currentGameBalance = game.getBalance();
				const deltaForRequest = currentGameBalance - lastSyncedBalance;

				// Include any pending stats from previous delayed syncs to prevent drift
				// If current round's stats haven't been included yet, add them now
				if (!statsIncluded) {
					pendingStats.winsIncrement += winsIncrement;
					pendingStats.lossesIncrement += lossesIncrement;
					pendingStats.handsIncrement += handsIncrement;
					// Track biggest win for this round (positive delta only)
					if (roundNetDelta > 0) {
						pendingStats.biggestWinCandidate = Math.max(
							pendingStats.biggestWinCandidate ?? 0,
							roundNetDelta,
						);
					}
					statsIncluded = true;
				}
				const finalWinsIncrement = pendingStats.winsIncrement;
				const finalLossesIncrement = pendingStats.lossesIncrement;
				const finalHandCount = pendingStats.handsIncrement;
				const finalBiggestWinCandidate = pendingStats.biggestWinCandidate;

				// Recompute outcome based on deltaForRequest for retries
				// When retrying after rate-limiting, deltaForRequest may include multiple rounds,
				// so we need to recompute the outcome to match the aggregated delta
				const outcomeForRequest: 'win' | 'loss' | 'push' =
					retryCount > 0
						? deltaForRequest > 0
							? 'win'
							: deltaForRequest < 0
								? 'loss'
								: 'push'
						: outcome;

				// Snapshot the stats we're about to send to avoid losing concurrent updates
				const snapshotPending = { ...pendingStats };

				const response = await fetch('/api/chips/update', {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						delta: deltaForRequest,
						gameType: 'baccarat',
						previousBalance: lastSyncedBalance,
						outcome: outcomeForRequest,
						handCount: finalHandCount,
						// Send accumulated stats including pending ones
						winsIncrement: finalWinsIncrement,
						lossesIncrement: finalLossesIncrement,
						// Send biggest win candidate for stats tracking
						biggestWinCandidate: finalBiggestWinCandidate,
					}),
				});

				if (response.ok) {
					// Subtract only the snapshot values we just synced (preserve concurrent updates)
					// Clamp to zero to prevent negative values from concurrent round race conditions
					pendingStats.winsIncrement = Math.max(
						0,
						pendingStats.winsIncrement - snapshotPending.winsIncrement,
					);
					pendingStats.lossesIncrement = Math.max(
						0,
						pendingStats.lossesIncrement - snapshotPending.lossesIncrement,
					);
					pendingStats.handsIncrement = Math.max(
						0,
						pendingStats.handsIncrement - snapshotPending.handsIncrement,
					);
					// If any pending stats remain, keep syncPending true for follow-up
					// Include biggestWinCandidate in the check to ensure it's sent in follow-up sync
					syncPending =
						pendingStats.winsIncrement > 0 ||
						pendingStats.lossesIncrement > 0 ||
						pendingStats.handsIncrement > 0 ||
						(pendingStats.biggestWinCandidate ?? 0) > 0;
					pendingStats.biggestWinCandidate = undefined;
					// Only reset statsIncluded if no follow-up sync pending
					// This prevents re-adding the current round's stats on follow-up sync
					if (!syncPending) {
						statsIncluded = false;
					}
					pendingRetryTimer = null;

					// Update our server-synced balance tracker after successful sync
					// Use the same balance reference that was used for the delta calculation
					lastSyncedBalance = currentGameBalance;
					if (retryCount > 0) {
						showStatus('Balance synced successfully.');
					}

					// Check for newly earned achievements
					const data = await response.json().catch((err: unknown) => {
						console.warn('[BALANCE_SYNC] Failed to parse success response JSON:', err);
						return {};
					});
					if (
						data.newAchievements &&
						Array.isArray(data.newAchievements) &&
						data.newAchievements.length > 0
					) {
						// Dispatch custom event for UI to handle
						window.dispatchEvent(
							new CustomEvent('achievement-earned', {
								detail: { achievements: data.newAchievements },
							}),
						);
					}
					return;
				}

				const errorData = (await response.json().catch((err: unknown) => {
					console.warn('[BALANCE_SYNC] Failed to parse error response JSON:', err);
					return {};
				})) as {
					error?: string;
					message?: string;
					currentBalance?: number;
				};

				// Special handling for RATE_LIMITED: retry after delay instead of reverting
				if (errorData.error === 'RATE_LIMITED' && retryCount < 3) {
					const retryAfterHeader = response.headers.get('Retry-After');
					const retryAfterSeconds = parseInt(retryAfterHeader || '2', 10);
					const retryAfterMs = (Number.isNaN(retryAfterSeconds) ? 2 : retryAfterSeconds) * 1000;
					console.warn(
						`Chip update rate limited, retrying in ${retryAfterMs}ms (attempt ${retryCount + 1})`,
					);
					showStatus('Syncing balance...');

					// Set syncPending to true only when first encountering rate limit
					// Stats are already added to pendingStats at the start of performChipUpdate
					if (!syncPending) {
						syncPending = true;
					}

					// Keep the current balance and retry after the rate limit window
					// Release the sync lock BEFORE scheduling the retry so the retry can acquire it
					isSyncInProgress = false;
					pendingRetryTimer = setTimeout(() => {
						void (async () => {
							try {
								await performChipUpdate(retryCount + 1);
							} catch (error) {
								console.error('Balance sync retry error:', error);
								showStatus('Network error. Balance sync failed.');
							}
						})();
					}, retryAfterMs + 100);
					return;
				}

				const hasServerBalance =
					errorData.currentBalance !== undefined && !Number.isNaN(Number(errorData.currentBalance));

				// For other errors, handle by reverting to server state when possible
				if (hasServerBalance) {
					const serverBalance = Number(errorData.currentBalance);
					lastSyncedBalance = serverBalance;
					game.applyServerBalance(serverBalance);
					updateUI();
					// Clear pending stats since we're reverting to server state
					pendingStats = {
						winsIncrement: 0,
						lossesIncrement: 0,
						handsIncrement: 0,
						biggestWinCandidate: undefined,
					};
					syncPending = false;
					statsIncluded = false;
					pendingRetryTimer = null;
					showStatus(`Balance sync corrected (server balance: ${serverBalance}).`);
				} else {
					const resolution = resolveBaccaratSyncState({
						error: errorData.error,
						hasServerBalance,
					});
					if (resolution.clearPendingStats) {
						pendingStats = {
							winsIncrement: 0,
							lossesIncrement: 0,
							handsIncrement: 0,
							biggestWinCandidate: undefined,
						};
						statsIncluded = false;
					}
					syncPending = resolution.syncPending;
					pendingRetryTimer = null;
				}

				if (errorData.error === 'BALANCE_MISMATCH') {
					console.warn('Balance mismatch detected, synced to server balance if provided.');
					showStatus('Balance corrected (server sync).');
				} else if (errorData.error === 'RATE_LIMITED') {
					// Max retries exceeded
					console.error('Chip update rate limited, max retries exceeded');
					showStatus('Sync delayed. Balance will update on next round.');
				} else if (errorData.error === 'DELTA_EXCEEDS_LIMIT') {
					console.error('Delta exceeded server limit:', errorData.message);
					showStatus('Payout exceeded limit. Please try a smaller bet.');
				} else if (errorData.error === 'INSUFFICIENT_BALANCE') {
					showStatus(errorData.message || 'Insufficient balance on server.');
				} else {
					console.error('Chip update failed:', errorData.error, errorData.message);
					showStatus('Balance sync failed. Will retry next round.');
				}
			} finally {
				// Only clear isSyncInProgress if no retry is pending
				// When retry is scheduled, the retry's finally block handles cleanup
				if (!pendingRetryTimer) {
					isSyncInProgress = false;
					// If syncPending is true after clearing isSyncInProgress, trigger follow-up sync
					// This handles the case where new rounds completed during a retry and queued their stats
					if (syncPending) {
						// Ensure statsIncluded stays true for follow-up so the original round stats
						// are not re-merged into pendingStats
						statsIncluded = true;
						void performChipUpdate().catch((error) => {
							console.error('Follow-up sync error:', error);
						});
					}
				}
			}
		};

		try {
			await performChipUpdate();
		} catch (error) {
			console.error('Balance sync error:', error);
			showStatus('Network error. Balance sync failed.');
			const resolution = resolveBaccaratSyncState({ error: undefined, hasServerBalance: false });
			if (resolution.clearPendingStats) {
				pendingStats = {
					winsIncrement: 0,
					lossesIncrement: 0,
					handsIncrement: 0,
					biggestWinCandidate: undefined,
				};
				statsIncluded = false;
			}
			syncPending = resolution.syncPending;
			pendingRetryTimer = null;
		}
	}

	// Initial UI update
	updateUI();

	// Achievement toast notification handler
	const achievementToast = document.getElementById('achievement-toast');
	const achievementIconEl = document.getElementById('achievement-icon');
	const achievementNameEl = document.getElementById('achievement-name');

	let enqueue: (achievements: Array<{ id: string; name: string; icon: string }>) => void;

	if (achievementToast && achievementIconEl && achievementNameEl) {
		const controller = initAchievementToast(() => ({
			toast: achievementToast,
			icon: achievementIconEl,
			name: achievementNameEl,
		}));
		enqueue = controller.enqueue;
	} else {
		// No-op if elements are missing
		enqueue = () => {};
	}

	window.addEventListener('achievement-earned', (event: Event) => {
		const customEvent = event as CustomEvent<{
			achievements: Array<{ id: string; name: string; icon: string }>;
		}>;
		const { achievements } = customEvent.detail;
		enqueue(achievements);
	});
</script>
